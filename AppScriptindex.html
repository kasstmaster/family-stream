<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ILYMMD+</title>

  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" as="style">
  <link rel="preload" href="https://i.postimg.cc/HkMtCdMK/ILYMMD-8-4-2025.png" as="image">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" media="all" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"></noscript>
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"></noscript>

<style>
/* =======================
   GLOBAL BASE STYLES
   ======================= */
:root {
  /* spacing & sizes you might tweak later */
}

body {
  font-family: Arial, sans-serif;
  background: #141414;
  color: #fff;
  margin: 0;
  font-size: 60px; /* mobile default */
}

#appContent {
  padding-top: 0;         /* header is static */
  padding-bottom: 120px;  /* make room for bottom bar */
}

/* =======================
   HEADER
   ======================= */
header {
  background: #000;
  box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  text-align: center;
  position: relative;
  z-index: 1;
}
header img {
  max-width: 350px;
  height: auto;
}

/* =======================
   EPISODES (same sizing as titles)
   ======================= */
.active-episode {
  outline: 3px solid #00a7b0;
  outline-offset: 2px;
}

/* NOTE:
   We intentionally DO NOT override width, fonts, or gap inside #episodesSection,
   so episode cards inherit the same .movie-card sizing as titles (mobile & desktop).
   If you previously had compact styles here, they've been removed. */

/* Ensure the trailer area is on top and interactive */
#tmdbTrailerContainer { position: relative; z-index: 1; }

/* Just in case: never disable pointer events on the preview or the container */
#tmdbDetailsPreview, #tmdbTrailerContainer, #tmdbTrailerFrame {
  pointer-events: auto !important;
}

/* =======================
   PROFILES
======================= */

#switchProfileBtn {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
}

#switchProfileBtn img {
  border-radius: 50%; /* circular icon */
}

.profile-btn {
  background: #1f1f1f;
  color: #fff;
  font-size: 30px;
  border: none;
  padding: 20px;
  border-radius: 20px;
  cursor: pointer;
  transition: background 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px; /* space between icon and name */
}

.profile-btn img {
  width: 100px;   /* icon size */
  height: 100px;
  border-radius: 50%; /* round icons */
  object-fit: cover;
}

.profile-btn:hover { 
  background: #00a7b0; 
}

/* =======================
   SEARCH BAR
   ======================= */
.search-bar {
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  height: 55px;
  background: #141414;
  padding: 10px 0;
  text-align: center;
  z-index: 10000;
}
.search-bar input {
  padding: 40px;
  width: 95%;
  max-width: 750px;
  font-size: 60px;
  border-radius: 12px;
  border: none;
}

/* =======================
   SECTION / TITLE HEADERS
   ======================= */
.section-title,
.tmdb-title {
  font-family: 'Roboto', sans-serif;
  font-weight: 700;
  font-size: 90px;
  text-align: center;
  color: #fff;
  position: sticky;
  top: 55px; /* height of search bar */
  background: #141414;
  z-index: 9999;
  padding-top: 30px;
  letter-spacing: 0.05em;
}
.section-title { margin: 80px auto 5px; }
.tmdb-title     { margin: 80px auto 40px; }

.section-title::before,
.tmdb-title::before {
  content: "";
  display: block;
  width: 100px;
  height: 6px;
  background-color: #00a7b0;
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  border-radius: 3px;
}

.subsection-title {
  font-family: 'Roboto', sans-serif;
  font-size: 80px;
  margin: 40px auto 20px;
  padding: 50px 20px 10px;
}

/* =======================
   SCROLL CONTAINERS
   ======================= */
.scroll-container {
  display: flex;
  gap: 30px;
  overflow-x: auto;
  padding: 0 20px 10px;
  position: relative; /* needed for seamless refresh overlay */
}
.scroll-container::-webkit-scrollbar { display: none; }

/* --- Seamless refresh overlay: keep content visible while fetching --- */
.scroll-container.is-refreshing::after {
  content: "";
  position: absolute; inset: 0;
  background: linear-gradient(0deg, rgba(20,20,20,0) 0%, rgba(20,20,20,0.25) 100%);
  pointer-events: none;
  border-radius: 0; /* inherits the container shape */
}
.scroll-container.is-refreshing::before {
  content: "";
  position: absolute; top: 12px; right: 12px;
  width: 18px; height: 18px; border-radius: 50%;
  border: 3px solid #666; border-top-color: #e50914;
  animation: spin .8s linear infinite;
  pointer-events: none;
  z-index: 1;
}

/* =======================
   LIST SIDEBAR REFRESH BUTTONS
   ======================= */
.list-row {
  display: grid;
  grid-template-columns: 70px 1fr; /* sidebar | list */
  align-items: start;
  gap: 10px;
}

.list-sidebar {
  display: flex;
  justify-content: center;
  padding-top: 6px;
}

/* Match the visual language of your bottom-bar .nav-item */
.list-sidebar .nav-item {
  width: 56px;
  text-align: center;
  user-select: none;
  cursor: pointer;
}
.list-sidebar .nav-item i { margin-bottom: 6px; }
.list-sidebar .nav-item span { font-size: 0.8em; }

/* =======================
   CARDS & ITEMS
   ======================= */
.movie-card,
.movie-item { border-radius: 12px; cursor: pointer; }

.movie-card {
  background: #1f1f1f;
  overflow: hidden;
  width: 350px;
  flex: 0 0 auto;
  position: relative;
  transition: none !important;
}
.movie-card:hover { transition: none !important; }

.movie-card img,
.movie-item img {
  width: 100%;
  display: block;
  border-radius: 12px;
}

.movie-title {
  padding: 24px;
  text-align: center;
  font-size: 60px;
}

/* Add / Request button on TMDb cards */
.add-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: #e50914;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 100px;
  height: 100px;
  font-size: 80px;
  line-height: 96px;
  cursor: pointer;
  z-index: 10;
  transition: background 0.3s ease;
}
.add-btn:hover { background: #ff4c4c; }

/* =======================
   SKELETON LOADER
   ======================= */
.skeleton-card {
  width: 350px;
  height: 450px;
  background: #2c2c2c;
  border-radius: 12px;
  animation: pulse 1.2s infinite;
}
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.6} }

/* =======================
   LOADING OVERLAY
   ======================= */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: #141414;
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  font-family: 'Roboto', sans-serif;
  font-size: 60px;
  z-index: 2147483647;
}

.loader {
  border: 12px solid #333;
  border-top: 12px solid #e50914;
  border-radius: 50%;
  width: 80px;
  height: 80px;
  animation: spin 1s linear infinite;
}
@keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

/* Inline loading label used next to buttons */
.loading-text {
  display: none;             /* hidden by default */
  font-weight: bold;
  color: #e50914;
  vertical-align: middle;
  margin-left: 8px;
  font-size: 24px;           /* base size, overridden in media queries */
}
.add-refresh-btn.loading + .loading-text { display: inline; }

/* Base style for the remove (‚Äì) button */
.cw-complete-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 28px;
  height: 28px;
  font-size: 18px;
  line-height: 1;
  border: none;
  border-radius: 50%;
  background-color: rgba(0,0,0,0.7);
  color: white;
  cursor: pointer;
  z-index: 3;
}

.cw-complete-btn:hover {
  transform: scale(1.06);
  background: #ff4c4c; /* brighter red on hover */
}

.cw-complete-btn:disabled {
  opacity: .6;
  cursor: default;
}

/* =======================
   NAV / BOTTOM BAR
   ======================= */
.bottom-bar {
  position: fixed;
  bottom: 0; left: 0;
  width: 100%;
  background: #000;
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  border-top: 1px solid #222;
  z-index: 9999;
}
.nav-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  color: #fff;
  font-size: 40px;
  cursor: pointer;
}
.nav-item i { font-size: 56px; margin-bottom: 8px; }
.nav-item:hover { color: #aaa; }

/* Refresh emoji (used in a few places) */
.refresh-emoji {
  cursor: pointer;
  user-select: none;
  font-size: 30px;           /* overridden in media queries */
  margin-left: 10px;
  vertical-align: middle;
  display: inline-block;
  transition: color 0.3s ease;
}
.refresh-emoji:hover,
.refresh-emoji:focus { color: #ff4c4c; outline: none; }
.refresh-emoji[aria-disabled="true"] {
  color: gray;
  cursor: default;
  pointer-events: none;
}

/* Episodes row controls */
.episodes-close {
  font-size: 0.9em;
  margin-left: 12px;
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  background: #333;
  color: #fff;
  cursor: pointer;
}
.episodes-close:hover { background: #444; }

/* =======================
   MODALS
   ======================= */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.95);
  justify-content: center;
  align-items: center;
  z-index: 2147483646;
  padding: 0;
}
.modal.active { display: flex !important; }

.modal-content {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 95vw;
  max-height: 80vh;
  background: #1f1f1f;
  overflow: hidden;
  border-radius: 12px;
}

/* =======================
   TEXT IN MODAL
   ======================= */
.movie-title-text {
  font-family: 'Roboto', sans-serif;
  font-weight: 700;
  font-size: 70px;
  margin-bottom: 30px;
  color: #fff;
  text-transform: uppercase;
}
.movie-overview {
  font-size: 40px !important;
  line-height: 1.8;
  color: #aaa;
  margin-bottom: 40px;
}

/* =======================
   POPUP
   ======================= */
#customPopup {
  display: none;
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: #222;
  color: #fff;
  padding: 30px 50px;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.8);
  font-size: 28px;
  z-index: 2147483646 !important;
  max-width: 90vw;
  text-align: center;
  width: 500px;
  box-sizing: border-box;
}

/* =======================
   MISC
   ======================= */
.sticky-shadow {
  box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  transition: box-shadow 0.3s ease;
}

.movie-card.last-watched {
  position: relative; /* ensure overlay anchors correctly */
}

.movie-card.last-watched::after {
  content: "Last watched";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  text-align: center;
  background: rgba(0, 167, 176, 0.92);
  color: #fff;
  font-weight: normal;
  padding: 14px 16px;
  border-radius: 12px 12px 0 0;
  z-index: 2;
  pointer-events: none;
  font-size: 15px;
}

/* =======================
   RESPONSIVE: MOBILE
   ======================= */
@media (max-width: 999px) {
  body { font-size: 30px !important; }

  #mobileRefreshButtonsContainer {
    display: flex !important;
    gap: 20px;
    justify-content: center;
    align-items: center;
  }

  .profile-btn img {
    width: 150px;
    height: 150px;
  }

  .movie-card.last-watched::after {
    font-size: 40px;        /* larger text for mobile */
    padding: 14px 16px;     /* taller banner for readability */
  }

  .cw-complete-btn {
    width: 100px !important;
    height: 100px !important;
    font-size: 80px !important;
    line-height: 96px !important;
  }

  #loadingScreen { font-size: 60px !important; }
  header img { max-width: 350px !important; }
  .search-bar input { font-size: 40px !important; }

  .section-title,
  .tmdb-title { box-shadow: none; transition: box-shadow 0.3s ease; }

  .sticky-shadow { box-shadow: 0 2px 5px rgba(0,0,0,0.7); }

  .section-title,
  .tmdb-title {
    font-size: 55px !important;
    margin: 60px auto 40px auto !important;
    padding-top: 24px !important;
    position: sticky !important;
    top: 55px !important;
    background: #141414 !important;
    z-index: 9999 !important;
  }
  .section-title { margin-bottom: 5px !important; }

  .section-title::before,
  .tmdb-title::before { width: 80px !important; height: 5px !important; }

  .subsection-title {
    font-size: 40px !important;
    padding: 30px 20px 10px;
  }

  .movie-card { width: 350px !important; }
  .movie-title { font-size: 40px !important; padding: 24px !important; }
  .skeleton-card { width: 350px !important; height: 450px !important; }

  .modal-content {
    flex-direction: column !important;
    max-width: 95vw !important;
    max-height: 80vh !important;
  }
  #videoFrameContainer { flex: 1 1 100% !important; min-height: 300px !important; width: 100% !important; }
  .movie-info-scroll { flex: 1 1 100% !important; width: 100% !important; padding: 30px !important; }
  .scroll-container { -webkit-overflow-scrolling: touch; /* smoother iOS scrolling */ }

  .refresh-emoji { font-size: 50px; }

  .movie-title-text { font-size: 70px !important; margin-bottom: 30px !important; }
  .movie-rating { font-size: 20px !important; margin-bottom: 20px !important; }
  .movie-overview { font-size: 30px !important; margin-bottom: 40px !important; }

  .loading-text { font-size: 40px !important; }

  .add-btn {
    width: 100px !important;
    height: 100px !important;
    font-size: 80px !important;
    line-height: 96px !important;
  }

  #customPopup {
    width: 90vw;
    padding: 40px 30px;
    font-size: 50px !important;
    top: 15%;
  }
  #popupCloseBtn { font-size: 50px !important; padding: 14px 40px; }
}

/* =======================
   RESPONSIVE: DESKTOP
   ======================= */
@media (min-width: 1000px) {
  body { font-size: 15px !important; }
  #loadingScreen { font-size: 20px !important; }
  header img { max-width: 150px !important; }
  .search-bar input { padding: 10px !important; font-size: 20px !important; }

  .nav-item { font-size: 15px !important; }
  .nav-item i { font-size: 20px !important; }

  .add-btn {
    width: 40px !important;
    height: 40px !important;
    font-size: 20px !important;
    line-height: 36px !important;
  }

  .refresh-emoji { font-size: 25px; }

  .loading-text { font-size: 15px !important; }

  #mobileRefreshButtonsContainer {
    display: flex !important;
    width: 100%;
    justify-content: space-around;
    align-items: center;
  }

  .section-title,
  .tmdb-title {
    font-size: 35px !important;
    margin: 40px auto 20px auto !important;
    padding-top: 12px !important;
    position: sticky !important;
    top: 55px !important;
    background: #141414 !important;
    z-index: 9999 !important;
  }
  .section-title { margin-bottom: 5px !important; }

  .section-title::before,
  .tmdb-title::before { width: 60px !important; height: 4px !important; }

  .subsection-title {
    margin: 0 !important;
    font-size: 20px !important;
    padding: 30px 20px 10px;
  }

  .movie-title { font-size: 15px !important; padding: 4px !important; }
  .movie-card { width: 150px !important; }
  .movie-card:hover { transform: none !important; }
  .skeleton-card { width: 150px !important; height: 200px !important; }

  .movie-info-scroll { padding: 10px !important; }
  .movie-title-text { font-size: 20px !important; margin-bottom: 10px !important; }
  .movie-rating { font-size: 15px !important; margin-bottom: 5px !important; }
  .movie-overview { font-size: 15px !important; margin-bottom: 10px !important; }

  .modal-content { max-width: 90vw !important; max-height: 70vh !important; }
  #videoFrameContainer { min-height: 150px !important; }

  /* visible scrollbars for desktop */
  .scroll-container { scrollbar-width: thin; scrollbar-color: #888 #1f1f1f; }
  .scroll-container::-webkit-scrollbar { height: 12px; }
  .scroll-container::-webkit-scrollbar-track { background: #1f1f1f; border-radius: 6px; }
  .scroll-container::-webkit-scrollbar-thumb { background: #888; border-radius: 6px; }
  .scroll-container::-webkit-scrollbar-thumb:hover { background: #aaa; }

    /* list sidebar ‚Äî desktop tweaks */
  .list-row { grid-template-columns: 44px 1fr; }
  .list-sidebar .nav-item { width: 36px !important; }
  .list-sidebar .nav-item span { display: none; } /* icon-only on desktop */
}

/* Disable hover scaling on touch devices */
@media (hover: none) and (pointer: coarse) {
  .movie-card:hover {
    transform: none !important;
  }
}

/* Keep the nice hover scale on real-hover devices (mice/trackpads) */
@media (hover: hover) and (pointer: fine) {
  .movie-card:hover {
    transform: none !important;
  }
}
</style>
</head>
<body>

<div id="profileModal" class="modal active" role="dialog" aria-modal="true">
  <div class="modal-content" style="align-items:center; justify-content:center; text-align:center; padding: 50px;">
    <h2 style="font-size: 60px; margin-bottom: 40px;">Who's watching?</h2>
    <div id="profileList" style="display: flex; gap: 40px; flex-wrap: wrap; justify-content: center;">    
      <button class="profile-btn" data-profile="Dave">
        <img src="https://i.postimg.cc/nVvJZm7y/dave.png" alt="Dave">
        <span>Dave</span>
      </button>    
      <button class="profile-btn" data-profile="Melissa">
        <img src="https://i.postimg.cc/htGW93wn/melissa.png" alt="Melissa">
        <span>Melissa</span>
      </button>
    
      <button class="profile-btn" data-profile="Ben">
        <img src="https://i.postimg.cc/D0K3LfVp/ben.jpg" alt="Ben">
        <span>Ben</span>
      </button>      
      <button class="profile-btn" data-profile="Kassandra">
        <img src="https://i.postimg.cc/Fzg5ZtNr/kassandra.jpg" alt="Kassandra">
        <span>Kassandra</span>
      </button>     
      <button class="profile-btn" data-profile="Aiden">
        <img src="https://i.postimg.cc/JhvL7cpL/aiden.png" alt="Aiden">
        <span>Aiden</span>
      </button>
      <button class="profile-btn" data-profile="Liadan">
        <img src="https://i.postimg.cc/RZbrGL5H/liadan.png" alt="Liadan">
        <span>Liadan</span>
      </button>
    </div>
  </div>
</div>

<div id="appContent" style="display: none;">

  <!-- App Content -->
  <header><br><br><img src="https://i.postimg.cc/HkMtCdMK/ILYMMD-8-4-2025.png" alt="ILYMMD+ Logo"><br><br></header>
  <div class="search-bar"><input type="text" id="searchInput" placeholder="Search movies or shows..."></div>

  <!-- Watch Header -->
  <h2 class="section-title">Available to Watch</h2>

  <!-- Episodes -->
  <div id="episodesSection" style="display:none;">
    <h2 class="subsection-title" id="episodesTitle"></h2>
    <div class="scroll-container" id="episodesGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- Continue Watching Section -->
  <div id="continueWatchingSection">
    <h2 class="subsection-title">Continue Watching</h2>
    <div class="scroll-container" id="continueWatchingGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- Recently Available Section -->
  <div id="recentlyAddedSection">
    <h2 class="subsection-title">Recently Added & Available</h2>
    <div class="scroll-container" id="recentlyAddedGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- All Available Section -->
  <div id="availableToWatchSection">
    <h2 class="subsection-title">All Available Movies & TV Shows</h2>
    <!-- Placeholders while loading -->
    <div class="scroll-container" id="availableToWatchGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <h2 class="tmdb-title">Explore</h2>

  <div id="tmdbDetailsPreview" 
      style="max-width: 900px; margin: 20px auto; background: #1f1f1f; border-radius: 12px; padding: 20px; color: white; display:none;">
    <div id="tmdbTrailerContainer" style="width: 100%; height: 450px; margin-bottom: 20px;"></div>
    <h2 class="movie-title-text" id="tmdbDetailsTitle"></h2>
    <p id="tmdbDetailsReleaseDate"></p>
    <p class="movie-overview" id="tmdbDetailsOverview"></p>
  </div>

  <div id="tmdbExploreAllSection">
    <h2 class="subsection-title">Explore All</h2>
    <div class="scroll-container" id="tmdbExploreAllRow"></div>
  </div>

  <!-- NEW: reveal button -->
  <div id="revealGenresWrap" style="text-align:center; margin: 10px 0 40px;">
    <button id="revealGenresBtn" type="button" aria-expanded="false"
            style="background:#00a7b0;color:#fff;border:none;border-radius:12px;padding:14px 24px;font-size:1em;cursor:pointer;">
      Explore Genres
    </button>
  </div>

  <!-- Make these hidden initially -->
  <div id="tmdbExploreComedySection" style="display:none;">
    <h2 class="subsection-title">Explore Comedy</h2>
    <div class="scroll-container" id="tmdbExploreComedyRow"></div>
  </div>

  <div id="tmdbExploreWesternSection" style="display:none;">
    <h2 class="subsection-title">Explore Western</h2>
    <div class="scroll-container" id="tmdbExploreWesternRow"></div>
  </div>

  <div id="tmdbExploreActionSection" style="display:none;">
    <h2 class="subsection-title">Explore Action</h2>
    <div class="scroll-container" id="tmdbExploreActionRow"></div>
  </div>

  <div id="tmdbExploreDramaSection" style="display:none;">
    <h2 class="subsection-title">Explore Drama</h2>
    <div class="scroll-container" id="tmdbExploreDramaRow"></div>
  </div>

  <div id="tmdbExploreAnimationSection" style="display:none;">
    <h2 class="subsection-title">Explore Animation</h2>
    <div class="scroll-container" id="tmdbExploreAnimationRow"></div>
  </div>

  <div id="tmdbExploreHistorySection" style="display:none;">
    <h2 class="subsection-title">Explore History</h2>
    <div class="scroll-container" id="tmdbExploreHistoryRow"></div>
  </div>

  <div id="tmdbExploreScifiSection" style="display:none;">
    <h2 class="subsection-title">Explore Sci‚ÄëFi</h2>
    <div class="scroll-container" id="tmdbExploreScifiRow"></div>
  </div>

  <!-- Wishlist Section -->
  <div id="wishlistSection">
    <h2 class="subsection-title">Wishlist</h2>
    <div class="scroll-container" id="wishlistGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- Search Results -->
  <div id="searchResultsSection" style="display:none;">
    <h2 class="subsection-title">Search Results</h2>
    <div class="scroll-container" id="searchResultsGrid"></div>
  </div>

  <!-- Custom Popup -->
  <div id="customPopup" role="status" aria-live="polite" aria-atomic="true" style="display:none; position: fixed; top: 20%; left: 50%; transform: translateX(-50%); background: #222; color: white; padding: 30px 50px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.8); font-size: 28px; z-index: 3000; max-width: 90vw; text-align: center;">
    <span id="popupMessage"></span>
    <button id="popupCloseBtn" style="display:block; margin: 20px auto 0 auto; padding: 10px 30px; font-size: 24px; border: none; border-radius: 8px; background: #e50914; color: white; cursor: pointer;">Close</button>
  </div>

  <div class="bottom-bar">
    <div id="mobileRefreshButtonsContainer" style="display:none; width: 100%; justify-content: space-around;">
      <div class="nav-item" id="mobileAvailableRefresh" role="button" tabindex="0" aria-label="Refresh Available to Watch">
        <i class="fa-solid fa-rotate"></i><span>Available</span>
      </div>
      <div class="nav-item" id="switchProfileBtn" role="button" tabindex="0" aria-label="Switch Profile">
        <img id="currentProfileIcon" src="https://via.placeholder.com/50" alt="Profile" style="width:50px;height:50px;object-fit:cover;border-radius:50%;margin-bottom:5px;">
        <span id="currentProfileName">Profile</span>
      </div>
      <div class="nav-item" id="mobileExploreRefresh" role="button" tabindex="0" aria-label="Refresh Explore">
        <i class="fa-solid fa-rotate"></i><span>Explore</span>
      </div>
    </div>
  </div>

</div>

<div id="loadingScreen" style="
  font-family: 'Roboto', sans-serif;
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  color: white;
  font-size: 48px;
  align-items: center;
  justify-content: center;
  z-index: 2147483647;
  pointer-events: auto; /* blocks clicks while visible */
  cursor: wait;
">
  Loading...
</div>

<script>
let fullLibrary = [];
let wishlistAvailableTitles = [];
let wishlistRequestedTitles = [];
let _recentlyCache = { items: [], stamp: 0 };
let _exploreCache = new Map();
let _nextAvailableSample = null;
let _hadSavedProfileAtLoad = false;
const _exploreNextSample = new Map();

let _cwPollTimer = null;
function startCWLiveSync() {
  if (_cwPollTimer) clearInterval(_cwPollTimer);
  _cwPollTimer = setInterval(() => {
    if (document.hidden) return; // pause when not visible
    loadContinueWatching();      // cheap refresh
  }, 60000); // 60s
}

let _wishlistAllCachePromise;
function ensureWishlistAll() {
  if (!_wishlistAllCachePromise) {
    _wishlistAllCachePromise = new Promise(res => {
      google.script.run
        .withSuccessHandler(items => {
          items = items || [];
          const norm = s => String(s || '').trim().toLowerCase();
          wishlistRequestedTitles = items.filter(x => norm(x.status) === "wishlist");
          wishlistAvailableTitles = items.filter(x => norm(x.status) === "available");
          res(items);
        })
        .withFailureHandler(() => res([]))
        .getWishlistAllWithStatus();
    });
  }
  return _wishlistAllCachePromise;
}

const appContent = document.getElementById('appContent');

let _lastFocus = null;

function forgetSelectedProfile() {
  try {
    localStorage.removeItem("lastProfileName");
    localStorage.removeItem("lastProfileIcon");
    console.log("Profile selection forgotten.");
  } catch (e) {
    console.warn("Unable to clear saved profile:", e);
  }

  currentProfile = null; // reset variable

  // Show profile picker
  const profileModal = document.getElementById("profileModal");
  if (profileModal) {
    profileModal.classList.add("active");
  }

  // Hide app content
  const app = document.getElementById("appContent");
  if (app) {
    app.style.display = "none";
  }
}

function selectProfile(profileName, iconUrl) {
  // Show loader over the modal first
  loadingScreen.style.display = "flex"; // overlays modal

  // Set current profile
  currentProfile = profileName;

  // Update bottom bar button
  const nameEl = document.getElementById("currentProfileName");
  const iconEl = document.getElementById("currentProfileIcon");
  if (nameEl) nameEl.textContent = currentProfile || "Profile";
  if (iconEl) iconEl.src = iconUrl || "https://via.placeholder.com/50";

  // Persist for next visit
  try {
    localStorage.setItem("lastProfileName", currentProfile);
    if (iconEl && iconEl.src) localStorage.setItem("lastProfileIcon", iconEl.src);
  } catch (e) {
    console.warn("localStorage unavailable:", e);
  }

  // Hide modal, keep app visible under loader
  const profileModal = document.getElementById("profileModal");
  const app = document.getElementById("appContent");
  profileModal.classList.remove("active");
  app.style.display = "block";

  // If no saved profile existed at load, start preloads now
  if (!_hadSavedProfileAtLoad) {
    Promise.all([ loadLibrary(), loadRecentlyAdded() ])
      .catch(err => {
        console.error("‚ùå Error during post-select preload:", err);
        showPopup("Something went wrong while loading content.");
      });
  }

  // Load CW first; hide loader as soon as CW is ready
  loadContinueWatching()
    .then(() => {
      const cw = document.getElementById("continueWatchingSection");
      if (cw) cw.style.display = "block";
      hideLoadingScreen(0);
      startCWLiveSync(); // 60s polling fallback
    })
    .catch(err => {
      console.error("‚ùå Error loading Continue Watching:", err);
      hideLoadingScreen(0);
      startCWLiveSync();
    });

  // Ensure wishlist cache once, then load Explore All + Wishlist
  ensureWishlistAll()
    .then(() => Promise.all([ loadExploreAllRow(), loadWishlist() ]))
    .then(() => {
      const wl = document.getElementById("wishlistSection");
      const ra = document.getElementById("recentlyAddedSection");
      if (wl) wl.style.display = "block";
      if (ra) ra.style.display = "block";
      return waitForImagesToLoad(app, { timeoutMs: 2500 });
    })
    .catch(err => {
      console.error("‚ùå Error during background loads:", err);
      showPopup("Some items are still loading. Try again if they don't appear.");
    });
}

function showPopup(messageHtml) {
  _lastFocus = document.activeElement;
  const popup = document.getElementById('customPopup');
  const msgSpan = document.getElementById('popupMessage');
  msgSpan.innerHTML = messageHtml;
  popup.style.display = 'block';
  document.getElementById('popupCloseBtn').focus();
}

document.getElementById('popupCloseBtn').addEventListener('click', () => {
  document.getElementById('customPopup').style.display = 'none';
  if (_lastFocus && typeof _lastFocus.focus === 'function') {
    _lastFocus.focus();
  }
});

document.addEventListener('keydown', (e) => {
  const popup = document.getElementById('customPopup');
  if (e.key === 'Escape' && popup.style.display === 'block') {
    document.getElementById('popupCloseBtn').click();
  }
});

// Remove an item from Continue Watching for this profile
function markComplete(profile, title, cardEl, episode = "") {
  if (!profile || !title) return;

  // Optimistic UI: disable button + fade card a bit
  const btn = cardEl.querySelector('.cw-complete-btn');
  if (btn) btn.disabled = true;
  cardEl.style.opacity = '0.6';

  google.script.run
    .withSuccessHandler(res => {
      // Remove the card from the UI
      cardEl.remove();

      // If the row goes empty, show the empty state
      const container = document.getElementById("continueWatchingGrid");
      if (container && container.children.length === 0) {
        container.innerHTML = "<p>No titles to continue watching yet.</p>";
      }

      // (Optional) toast
      showPopup(`<b>${title}</b><br><span style="color:limegreen;">Removed from Continue Watching.</span>`);
    })
    .withFailureHandler(err => {
      // Roll back UI on error
      if (btn) btn.disabled = false;
      cardEl.style.opacity = '1';
      showPopup(`‚ùå Couldn't remove <b>${title}</b>.<br>${err?.message || 'Please try again.'}`);
    })
    .clearProfileProgress(profile, title);
}

// Normalize for CW keys / lookups
const _normCW = s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();

/** Build one CW card (matches renderContinueWatching look & behavior) */
function makeCWCard(driveItem, episode = "") {
  const card = document.createElement("div");
  card.className = "movie-card";
  card.style.position = "relative";
  card.dataset.titleNorm = _normCW(driveItem.title);
  card.innerHTML = `
    <img src="${driveItem.poster}" alt="${driveItem.title}" loading="lazy" decoding="async">
    <div class="movie-title">${driveItem.title}</div>
    <button class="cw-complete-btn" title="Remove from Continue Watching" aria-label="Remove ${driveItem.title} from Continue Watching">‚àí</button>
  `;

  // open episodes on card click (but not when clicking the minus)
  card.addEventListener("click", (e) => {
    if (e.target && typeof e.target.closest === "function" && e.target.closest(".cw-complete-btn")) return;
    // show the episodes list
    const local = findLocalByTitle(driveItem.title);
    if (local) showEpisodesList(local);
  });

  // minus button wiring
  const btn = card.querySelector(".cw-complete-btn");
  if (btn) {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const confirmMsg = episode
        ? `Mark "${driveItem.title}" ‚Äî "${episode}" as complete?`
        : `Mark "${driveItem.title}" as complete?`;
      if (!window.confirm(confirmMsg)) return;
      markComplete(currentProfile, driveItem.title, card, episode || "");
      // üîî broadcast removal to other tabs
      try {
        localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
          t: Date.now(), action: "remove", title: driveItem.title
        }));
      } catch(_) {}
    });
  }
  return card;
}

/** Upsert a CW card at the top (instant UI update) */
function upsertContinueWatchingCard(title, episode = "") {
  const grid = document.getElementById("continueWatchingGrid");
  if (!grid || !window.library) return;

  // find matching item in your library
  const local = findLocalByTitle(title);
  if (!local) return;

  const key = _normCW(title);

  // if empty state text is there, clear it
  if (!grid.querySelector(".movie-card") && grid.textContent.includes("No titles to continue watching")) {
    grid.innerHTML = "";
  }

  // Look for existing card
  let card = Array.from(grid.children).find(el => el.dataset?.titleNorm === key);

  if (card) {
    // move to top and update button episode context
    grid.insertBefore(card, grid.firstChild);
    const minus = card.querySelector(".cw-complete-btn");
    if (minus) {
      minus.title = episode
        ? `Remove "${title}" ‚Äî "${episode}" from Continue Watching`
        : `Remove "${title}" from Continue Watching`;
    }
  } else {
    // create new card and prepend
    const newCard = makeCWCard(local, episode);
    grid.insertBefore(newCard, grid.firstChild);
  }

  // ensure section visible
  const section = document.getElementById("continueWatchingSection");
  if (section) section.style.display = "block";

  // keep the in-memory cache aligned so last-watched highlighting works
  cwProgressByTitle.set(_norm(title), String(episode || ""));
  try { localStorage.setItem(`lastWatched_${_norm(title)}`, String(episode || "")); } catch(_) {}

  // üîî broadcast upsert to other tabs
  try {
    localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
      t: Date.now(), action: "upsert", title, episode
    }));
  } catch(_) {}
}

function waitForImagesToLoad(container, { timeoutMs = 2500 } = {}) {
  // Fast‚Äëpath: if container missing, resolve immediately
  if (!container) return Promise.resolve();

  const images = Array.from(container.querySelectorAll("img"));

  // Fast‚Äëpath: nothing to wait on
  if (images.length === 0) return Promise.resolve();

  const inViewport = el => {
    const r = el.getBoundingClientRect();
    return r.top < window.innerHeight && r.bottom > 0 && r.left < window.innerWidth && r.right > 0;
  };

  const promises = images.map(img => {
    // Already loaded (covers cached images and ones with naturalWidth > 0)
    if (img.complete || img.naturalWidth > 0) return Promise.resolve();

    // If it's lazy and off‚Äëscreen, don't block the loader on it
    const isLazy = img.loading === 'lazy' || img.getAttribute('loading') === 'lazy';
    if (isLazy && !inViewport(img)) return Promise.resolve();

    // Otherwise, wait for load/error
    return new Promise(resolve => {
      const done = () => { img.onload = img.onerror = null; resolve(); };
      img.onload = done;
      img.onerror = done;
    });
  });

  const timeout = new Promise(res => setTimeout(res, timeoutMs));
  return Promise.race([Promise.all(promises), timeout]);
}

function withSeamlessOverlay(el, fn) {
  if (!el) return fn();
  el.classList.add('is-refreshing');
  return Promise.resolve()
    .then(fn)
    .finally(() => el.classList.remove('is-refreshing'));
}

function replaceChildrenFast(el, newChildrenFragment) {
  while (el.firstChild) el.removeChild(el.firstChild);
  el.appendChild(newChildrenFragment);
}

// Create card
function createCard(item, isTMDb = false, wishlistTitles = []) {
  const displayTitle = item.title || item.name || "No Title";
  const card = document.createElement("div");
  card.classList.add("movie-card");
  card.innerHTML = "";

  // Poster
  const img = document.createElement("img");
  img.src = item.poster;
  img.alt = displayTitle;
  img.loading = "lazy";
  card.appendChild(img);

  // Title
  const titleDiv = document.createElement("div");
  titleDiv.classList.add("movie-title");
  titleDiv.textContent = displayTitle;
  card.appendChild(titleDiv);

  // Wishlist button for TMDb items
  if (isTMDb) {
    // Store TMDb genre IDs for filtering
    const gids = Array.isArray(item.genre_ids) ? item.genre_ids : [];
    const btn = document.createElement("button");
    btn.classList.add("add-btn");

    const alreadyRequested = (wishlistTitles || []).some(w =>
      String(w.title || "").toLowerCase().trim() === displayTitle.toLowerCase().trim() &&
      w.status === "Wishlist"
    );

    if (alreadyRequested) {
      btn.textContent = "‚úî";
      btn.title = "Requested";
      btn.disabled = true;
      btn.style.backgroundColor = "green";
    } else {
      btn.textContent = "+";
      btn.title = "Add to Wishlist";
      btn.style.backgroundColor = "#e50914";
      btn.addEventListener("click", e => {
        e.stopPropagation();
        addToWishlist(displayTitle, item.poster, btn);
      });
    }
    card.appendChild(btn);
  }

  card.addEventListener("click", async () => {
    if (isTMDb) {
      // TMDb items: populate the TMDb Details Preview
      const preview = document.getElementById("tmdbDetailsPreview");
      const trailerContainer = document.getElementById("tmdbTrailerContainer");
      const titleEl = document.getElementById("tmdbDetailsTitle");
      const dateEl = document.getElementById("tmdbDetailsReleaseDate");
      const ovEl = document.getElementById("tmdbDetailsOverview");

      const data = await fetchTMDbDetails(item, item.media_type === "tv");
      if (!data) return;

      const trailer = data.videos?.results.find(v => v.type === "Trailer" && v.site === "YouTube");
      if (trailerContainer) {
        trailerContainer.innerHTML = trailer
          ? `<iframe id="tmdbTrailerFrame" src="https://www.youtube.com/embed/${trailer.key}"
               sandbox="allow-same-origin allow-scripts allow-presentation allow-popups allow-forms"
               allowfullscreen style="width:100%;height:100%;border:none;border-radius:12px;"></iframe>`
          : `<p><em>No trailer available.</em></p>`;
      }

      const titleText = data.name || data.title || displayTitle;
      if (titleEl) titleEl.textContent = titleText;
      if (dateEl) dateEl.innerHTML = `<strong>Release Date:</strong> ${data.first_air_date || data.release_date || "N/A"}`;
      if (ovEl) ovEl.textContent = data.overview || "No overview available.";

      if (preview) {
        preview.style.display = "block";
        setTimeout(() => preview.scrollIntoView({ behavior: "smooth", block: "start" }), 50);
      }

      // If there‚Äôs a matching local item with episodes, also show the episodes list beneath sections
      const local = findLocalByTitle(titleText);
      if (local?.episodes?.length) {
        showEpisodesList(local);
      } else {
        const epSec = document.getElementById("episodesSection");
        const epGrid = document.getElementById("episodesGrid");
        if (epSec) epSec.style.display = "none";
        if (epGrid) epGrid.innerHTML = "";
      }

    } else {
      // Local items: do NOT touch the TMDb Details Preview at all
      // Just open the episodes list
      showEpisodesList(item);
    }
  });

  return card;
}

function openEpisodeInNewTab(url, showTitle, episodeTitle = "") {
  // üîπ instant local UI: add/update CW immediately
  if (currentProfile && showTitle) {
    upsertContinueWatchingCard(showTitle, episodeTitle);

    // persist to server (fire-and-forget)
    google.script.run
      .withFailureHandler(err => console.warn("saveProfileProgress failed:", err))
      .saveProfileProgress(currentProfile, showTitle, episodeTitle);
  }

  // also keep Available row feeling fresh
  try { updateAvailableToWatchRow(); } catch(_) {}

  // open in a new tab (popup-safe)
  try {
    window.open(url, "_blank", "noopener");
  } catch (e) {
    location.href = url;
  }
}

function showEpisodesList(showLike) {
  // Ensure episodesSection exists
  let section = document.getElementById("episodesSection");
  if (!section) {
    section = document.createElement("div");
    section.id = "episodesSection";
    section.style.display = "none";
    section.innerHTML = `
      <h2 class="subsection-title" id="episodesTitle"></h2>
      <div class="scroll-container" id="episodesGrid"></div>
    `;
    const cwSection = document.getElementById("continueWatchingSection");
    if (cwSection) cwSection.insertAdjacentElement("beforebegin", section);
    else document.body.appendChild(section);
  }

  const titleEl = document.getElementById("episodesTitle");
  const grid = document.getElementById("episodesGrid");
  if (!grid) return;

  // Hide TMDb preview for local items
  const preview = document.getElementById("tmdbDetailsPreview");
  if (preview) preview.style.display = "none";

  // Clear + show section
  grid.innerHTML = "";
  section.style.display = "block";

  const displayTitle = showLike.title || showLike.name || "Episodes";
  let eps = Array.isArray(showLike.episodes) ? [...showLike.episodes] : [];

  // If no episodes on the object, fetch them from the server by title.
  if (!eps.length && (showLike.title || showLike.name)) {
    const wantTitle = showLike.title || showLike.name;

    // Temporarily show a loading state in the grid
    const gridEl = document.getElementById("episodesGrid");
    if (gridEl) gridEl.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">Loading episodes‚Ä¶</p>';

    google.script.run
      .withSuccessHandler(payload => {
        const fromServer = Array.isArray(payload?.episodes) ? payload.episodes : [];
        if (!fromServer.length && payload?.url) {
          fromServer.push({ title: "Play", url: payload.url, poster: payload.poster || showLike.poster });
        }
        showEpisodesList({
          title: payload.title || wantTitle,
          poster: payload.poster || showLike.poster,
          episodes: fromServer
        });
      })
      .withFailureHandler(() => {
        if (gridEl) gridEl.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">No episodes found.</p>';
      })
      .getEpisodesByTitle(wantTitle);
    return; // stop here; the success handler will re-render
  }

  // If no episodes but we have a direct URL, create a single "Play" card
  if ((!eps || eps.length === 0) && showLike.url) {
    eps = [{ title: "Play", url: showLike.url }];
  }

  // ‚úÖ Sort episodes alphabetically by title (case-insensitive)
  eps.sort((a, b) => {
    return (a.title || "").toLowerCase().localeCompare((b.title || "").toLowerCase());
  });

  const label = (eps.length > 1) ? "Episodes" : "Collection";
  titleEl.innerHTML = `${displayTitle} ‚Äî <span style="opacity:.8">${label}</span>`;

  // Close button
  let closeBtn = titleEl.querySelector("button.episodes-close");
  if (!closeBtn) {
    closeBtn = document.createElement("button");
    closeBtn.className = "episodes-close";
    closeBtn.type = "button";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => {
      section.style.display = "none";
      grid.innerHTML = "";
    });
    titleEl.appendChild(closeBtn);
  }

  // Build cards
  if (!eps || eps.length === 0) {
    grid.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">No episodes found.</p>';
  } else {
    const last = getLastWatchedEpisodeFor(displayTitle);
    eps.forEach(ep => {
      const card = document.createElement("div");
      card.className = "movie-card";
      if (_norm(ep.title) === _norm(last)) card.classList.add("last-watched");
      card.innerHTML = `
        <img src="${ep.poster || showLike.poster}" alt="${ep.title}" loading="lazy">
        <div class="movie-title">${ep.title}</div>
      `;
        card.addEventListener("click", () => {
        // Visually select + mark as last watched immediately
        grid.querySelectorAll(".movie-card").forEach(c => 
          c.classList.remove("active-episode", "last-watched")
        );
        card.classList.add("active-episode", "last-watched");

        // Update in-memory + localStorage so UI updates without refresh
        saveLastWatchedEpisodeFor(displayTitle, ep.title);

        // üîÅ Refresh the "Available to Watch" row live
        updateAvailableToWatchRow();

        // Persist to sheet (your existing behavior) + open
        openEpisodeInNewTab(ep.url, displayTitle, ep.title);
      });
      grid.appendChild(card);
    });
  }

  // Auto-scroll to last watched (double RAF to ensure layout on mobile)
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      const lastWatchedCard = grid.querySelector(".last-watched");
      if (lastWatchedCard) {
        lastWatchedCard.classList.add("active-episode"); // optional
        scrollCardIntoViewHorizontally(grid, lastWatchedCard, { smooth: true });
      }
    });
  });

  // Smooth scroll the section into view (account for sticky header)
  setTimeout(() => {
    const yOffset = -80; // adjust for sticky header height
    const y = section.getBoundingClientRect().top + window.scrollY + yOffset;
    window.scrollTo({ top: y, behavior: 'smooth' });
  }, 50);
}

// (Optional but harmless): ensure global
window.showEpisodesList = showEpisodesList;

// --- Available-to-Watch (batched) ---
const availableState = {
  initialized: false,
  loading: false,
  loaded: 0,
  items: [],
};

function buildAvailableList() {
  if (!window.library) return [];
  const { movies = [], tv = [] } = window.library;
  // Shuffle a fresh combined list
  return shuffleArray([...movies, ...tv]);
}

function appendAvailableItems(limit = 5) {
  const grid = document.getElementById("availableToWatchGrid");
  if (!grid || !availableState.items.length) return;

  const start = availableState.loaded;
  const end = Math.min(start + limit, availableState.items.length);
  for (let i = start; i < end; i++) {
    grid.appendChild(createCard(availableState.items[i]));
  }
  availableState.loaded = end;
}

function initAvailableToWatch({ allowSkeletons = true } = {}) {
  const grid = document.getElementById("availableToWatchGrid");
  if (!grid) return;

  // Rebuild fresh shuffled list
  availableState.initialized = false;
  availableState.loading = false;
  availableState.loaded = 0;
  availableState.items = buildAvailableList();

  // If nothing at all, show empty state and bail
  if (!availableState.items || availableState.items.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center; width:100%;">No videos available.</p>';
    return;
  }

  const alreadyHasCards = !!grid.querySelector(".movie-card");

  // Only show skeletons when it's the *very first* paint (no cards yet)
  if (allowSkeletons && !alreadyHasCards) {
    grid.innerHTML = `
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    `;
  }

  // Build off-DOM and swap in atomically (no flicker either way)
  requestAnimationFrame(() => {
    const frag = document.createDocumentFragment();
    const limit = 10;
    availableState.items.slice(0, limit).forEach(it => frag.appendChild(createCard(it)));
    replaceChildrenFast(grid, frag);
    availableState.loaded = Math.min(limit, availableState.items.length);
    availableState.initialized = true;
  });
}

// Load Library via google.script.run and sync wishlist statuses automatically
function loadLibrary({ force = false, showSkeletons = true } = {}) {
  // skip if already loaded and not forcing
  if (libraryLoaded && !force) return Promise.resolve();

  const grid = document.getElementById("availableToWatchGrid");

  if (showSkeletons && grid) {
    grid.innerHTML = `
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    `;
  }

  return new Promise(resolve => {
    google.script.run
      .withSuccessHandler(data => {
        fullLibrary = (data.movies || []).concat(data.tv || []);
        window.library = data;
        libraryLoaded = true;

        try {
          initAvailableToWatch({ allowSkeletons: showSkeletons });
        } catch (err) {
          console.error("‚ùå Error in initAvailableToWatch:", err);
          showPopup("Error rendering Available to Watch.");
        }
        resolve();
      })
      .withFailureHandler(err => {
        console.error("‚ùå Failed to load library:", err);
        if (showSkeletons && grid) {
          grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">Error loading library.</p>';
        }
        resolve();
      })
      .getLibraryAndSyncWishlist();
  });
}

function buildCardsFragment(items, limit = 10) {
  const frag = document.createDocumentFragment();
  const slice = items.slice(0, limit);
  slice.forEach((item, idx) => {
    const card = createCard(item);
    // Nudge first few posters to load sooner for snappier visual completion
    const img = card.querySelector('img');
    if (img) {
      img.decoding = 'async';
      if (idx < 4) img.loading = 'eager';
      if (idx < 2) img.fetchPriority = 'high'; // üëà new
    }
    frag.appendChild(card);
  });
  return frag;
}

function prewarmAvailableSample(limit = 10) {
  // Fire & forget: warms a ready-to-render set for the next refresh
  callScript('getRandomLibrarySample', limit).then(sample => {
    _nextAvailableSample = Array.isArray(sample) && sample.length ? sample : null;
  }).catch(() => { _nextAvailableSample = null; });
}

async function refreshAvailableToWatch({ limit = 10 } = {}) {
  const grid = document.getElementById('availableToWatchGrid');
  if (!grid) return;

  await withSeamlessOverlay(grid, async () => {
    // 1) Use a prewarmed set immediately if we have it
    let sample = _nextAvailableSample;
    _nextAvailableSample = null; // consume it

    // 2) If no prewarm available, fetch one now
    if (!sample) {
      sample = await callScript('getRandomLibrarySample', limit);
    }

    // 3) If we got a server-sampled set, render that
    if (Array.isArray(sample) && sample.length) {
      const frag = buildCardsFragment(sample, limit);
      replaceChildrenFast(grid, frag);

      // keep overlay until first few images actually paint (like Explore feel)
      await waitForImagesToLoad(grid, { timeoutMs: 900 });

      // update state
      availableState.items = sample.slice();
      availableState.loaded = Math.min(limit, sample.length);
      availableState.initialized = true;
      availableState.loading = false;

      // 4) Prewarm the *next* batch in the background
      prewarmAvailableSample(limit);
      return;
    }

    // 5) Fallback to local library (no Drive roundtrip)
    if (!window.library) {
      await loadLibrary({ force: false, showSkeletons: false });
    }
    const newItems = buildAvailableList();

    if (!Array.isArray(newItems) || newItems.length === 0) {
      grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center; width:100%;">No videos available.</p>';
      availableState.items = [];
      availableState.loaded = 0;
      return;
    }

    const frag = buildCardsFragment(newItems, limit);
    replaceChildrenFast(grid, frag);

    // Hold overlay just long enough for posters to pop in
    await waitForImagesToLoad(grid, { timeoutMs: 900 });

    availableState.items = newItems.slice();
    availableState.loaded = Math.min(limit, newItems.length);
    availableState.initialized = true;
    availableState.loading = false;

    // Still prewarm for the *next* click
    prewarmAvailableSample(limit);
  });
}

/**
 * Prewarm a future set for an Explore row so refresh can be instant.
 * @param {string} rowId   - e.g. 'tmdbExploreAllRow'
 * @param {string} genreId - TMDb genre id ('' means "All")
 * @param {number} count   - how many items to prefetch
 */
function prewarmExploreRow(rowId, genreId = '', count = 16) {
  // Fire & forget
  fetchMixedTopRated(genreId, count)
    .then(items => {
      if (Array.isArray(items) && items.length) {
        _exploreNextSample.set(rowId, items.slice(0, count));
      } else {
        _exploreNextSample.delete(rowId);
      }
    })
    .catch(() => _exploreNextSample.delete(rowId));
}

// Live refresh helper for the Available row
function updateAvailableToWatchRow() {
  // quick reshuffle/rebuild without a Drive call
  try { refreshAvailableToWatch(); } catch (e) { console.warn(e); }
}

let currentProfile = null;

const loadingScreen = document.getElementById("loadingScreen");
let _hideLoaderTimer = null;
function hideLoadingScreen(delay = 300) {
  if (_hideLoaderTimer) {
    clearTimeout(_hideLoaderTimer);
    _hideLoaderTimer = null;
  }
  _hideLoaderTimer = setTimeout(() => {
    loadingScreen.style.display = "none";
    _hideLoaderTimer = null;
  }, delay);
}

window.addEventListener("load", () => {
  const app = document.getElementById("appContent");
  const profileModal = document.getElementById("profileModal");

  app.style.display = "block";
  loadingScreen.style.display = "flex";

  let savedName = null, savedIcon = null;
  try {
    savedName = localStorage.getItem("lastProfileName");
    savedIcon = localStorage.getItem("lastProfileIcon") || "https://via.placeholder.com/50";
  } catch (e) {
    console.warn("localStorage unavailable:", e);
  }

  if (savedName) {
    _hadSavedProfileAtLoad = true;

    // Start profile flow immediately (CW can start sooner)
    profileModal.classList.remove("active");
    selectProfile(savedName, savedIcon);

    // Warm above-the-fold rows in parallel
    Promise.all([ loadLibrary(), loadRecentlyAdded() ])
      .then(() => waitForImagesToLoad(app, { timeoutMs: 2500 }))
      .then(() => hideLoadingScreen())
      .catch(err => {
        console.error("‚ùå Error during preload:", err);
        showPopup("Something went wrong while preloading content.");
        hideLoadingScreen();
      });
  } else {
    _hadSavedProfileAtLoad = false;

    // No saved profile ‚Üí show modal, do NOT preload library/recently
    profileModal.classList.add("active");
    hideLoadingScreen(0); // remove loader right away
  }

  // Manual profile selection
  document.querySelectorAll(".profile-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const chosenName = btn.dataset.profile;
      const imgEl = btn.querySelector("img");
      const chosenIcon = imgEl ? imgEl.src : "https://via.placeholder.com/50";
      selectProfile(chosenName, chosenIcon);
    });
  });

  // Switch profile from bottom bar
  const switchBtn = document.getElementById("switchProfileBtn");
  if (switchBtn) {
    switchBtn.addEventListener("click", () => {
      forgetSelectedProfile(); // clear saved profile & show modal
    });
  }

  // NEW: ‚ÄúExplore genres‚Äù button
  const revealBtn = document.getElementById('revealGenresBtn');
  if (revealBtn) {
    revealBtn.addEventListener('click', revealAndLoadAllGenres);
  }

  // == Attach sidebar refresh buttons for all visible lists
  attachAllListSidebars();

  // == Ensure sidebars appear after user reveals hidden genre rows
  const _origReveal = revealAndLoadAllGenres;
  window.revealAndLoadAllGenres = async function(...args) {
    const res = await _origReveal.apply(this, args);
    attachAllListSidebars(); // rows now exist & are visible
    return res;
  };

  // üî• Prewarm the first Available-to-Watch batch for instant refresh
  prewarmAvailableSample(10);

  // üî• Prewarm Explore All so its first refresh is instant
  prewarmExploreRow('tmdbExploreAllRow', '', 16);
});

document.getElementById("searchInput").addEventListener("input", function (e) {
  const query = (e.target.value || "").toLowerCase().trim();
  const searchResults = document.getElementById("searchResultsSection");
  const searchGrid = document.getElementById("searchResultsGrid");

  // Everything we hide/show during search
  const sectionsToToggle = [
    "continueWatchingSection",
    "recentlyAddedSection",
    "availableToWatchSection",
    "wishlistSection",
    "tmdbDetailsPreview",
    "episodesSection",
    "tmdbExploreAllSection",
    "tmdbExploreComedySection",
    "tmdbExploreWesternSection",
    "tmdbExploreActionSection",
    "tmdbExploreDramaSection",
    "tmdbExploreAnimationSection",
    "tmdbExploreHistorySection",
    "tmdbExploreScifiSection"
  ];

  // If the library isn't ready, bail
  if (!Array.isArray(fullLibrary) || fullLibrary.length === 0) return;

  if (query === "") {
    // Always restore these
    ["continueWatchingSection","recentlyAddedSection","availableToWatchSection",
    "wishlistSection","tmdbDetailsPreview","episodesSection","tmdbExploreAllSection"]
      .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = "block"; });

    // Only show per-genre sections if user revealed them
    const genreSections = [
      "tmdbExploreComedySection","tmdbExploreWesternSection","tmdbExploreActionSection",
      "tmdbExploreDramaSection","tmdbExploreAnimationSection","tmdbExploreHistorySection",
      "tmdbExploreScifiSection"
    ];
    genreSections.forEach(id => {
      const el = document.getElementById(id);
      if (!el) return;
      el.style.display = _genresRevealed ? "block" : "none";
    });

    // Show the Explore header
    const tmdbHeader = document.querySelector(".tmdb-title");
    if (tmdbHeader) tmdbHeader.style.display = "block";

    // Hide search results
    if (searchResults) searchResults.style.display = "none";
    if (searchGrid) searchGrid.innerHTML = "";
    return;
  }

  // Hide all non-search sections
  sectionsToToggle.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
  // Hide the Explore header (h2.tmdb-title)
  const tmdbHeader = document.querySelector(".tmdb-title");
  if (tmdbHeader) tmdbHeader.style.display = "none";

  // Show and populate search results
  if (searchResults) searchResults.style.display = "block";
  if (searchGrid) {
    searchGrid.innerHTML = "";
    const filtered = fullLibrary.filter(item =>
      (item.title || "").toLowerCase().includes(query)
    );
    if (filtered.length) {
      filtered.forEach(item => searchGrid.appendChild(createCard(item)));
    } else {
      searchGrid.innerHTML = '<p style="text-align:center;color:#aaa;font-size:24px;">No results found.</p>';
    }
  }
});

// Live sync CW across tabs/windows via localStorage events
window.addEventListener("storage", (e) => {
  if (!e || !e.key || !currentProfile) return;
  const wantKey = `cwSync:${currentProfile}`;
  if (e.key !== wantKey) return;

  try {
    const msg = JSON.parse(e.newValue || "{}");
    if (!msg || !msg.action || !msg.title) return;

    if (msg.action === "upsert") {
      upsertContinueWatchingCard(msg.title, msg.episode || "");
    } else if (msg.action === "remove") {
      const grid = document.getElementById("continueWatchingGrid");
      if (!grid) return;
      const key = (s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase())(msg.title);
      const card = Array.from(grid.children).find(el => el.dataset?.titleNorm === key);
      if (card) card.remove();
      if (grid.children.length === 0) {
        grid.innerHTML = "<p>No titles to continue watching yet.</p>";
      }
    }
  } catch(_) {}
});

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const _norm = s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();
function findLocalByTitle(title) {
  if (!title || !window.library) return null;
  const { movies = [], tv = [] } = window.library;
  return [...movies, ...tv].find(x => _norm(x.title) === _norm(title)) || null;
}

// Cache of "last watched" by normalized title for current profile
let cwProgressByTitle = new Map();

function setCWCache(items = []) {
  cwProgressByTitle.clear();
  items.forEach(it => {
    if (it && it.title) {
      cwProgressByTitle.set(_norm(it.title), String(it.episode || ""));
    }
  });
}

function getLastWatchedEpisodeFor(title) {
  const k = _norm(title);
  if (cwProgressByTitle.has(k)) return cwProgressByTitle.get(k) || "";
  try {
    return localStorage.getItem(`lastWatched_${k}`) || "";
  } catch (_) {
    return "";
  }
}

function saveLastWatchedEpisodeFor(showTitle, episodeTitle) {
  try {
    const key = `lastWatched_${_norm(showTitle)}`;
    localStorage.setItem(key, episodeTitle);
  } catch (err) {
    console.error("Could not save last watched:", err);
  }
}

// Horizontal scroll centering helper (mobile + desktop safe)
function scrollCardIntoViewHorizontally(container, card, { smooth = true } = {}) {
  if (!container || !card) return;
  const cardCenter = card.offsetLeft + card.offsetWidth / 2;
  const target = Math.max(0, cardCenter - container.clientWidth / 2);
  container.scrollTo({ left: target, top: 0, behavior: smooth ? 'smooth' : 'auto' });
}

// WISHLIST
function addToWishlist(title, poster, btn) {
  // Immediately update UI
  if (btn) {
    btn.textContent = "‚úî";
    btn.style.backgroundColor = "green";
    btn.disabled = true;
  }

  google.script.run.withSuccessHandler(response => {
    if (!response) return;
    showPopup(`<b>${response.title}</b><br><span style="color:green;">Added to your wishlist!</span>`);
  }).withFailureHandler(err => {
    showPopup(`‚ùå Failed to add <b>${title}</b>. Error: ${err.message}`);
    // On failure, revert button UI back
    if (btn) {
      btn.textContent = "+";
      btn.style.backgroundColor = "#e50914";
      btn.disabled = false;
    }
  }).addToWishlistSheet(title, poster);
}
function renderWishlist(items) {
  const grid = document.getElementById('wishlistGrid');
  grid.innerHTML = '';

  // Normalize shapes/keys coming from server: {title, poster} OR {Title, Poster} etc.
  const normalized = (Array.isArray(items) ? items : []).map(it => {
    const title = (it && (it.title || it.Title || it.name || it.Name)) || 'Untitled';
    const poster = (it && (it.poster || it.Poster || it.image || it.Image)) || '';
    return { title: String(title).trim(), poster: String(poster).trim() };
  }).filter(it => it.title); // keep only valid titles

  if (normalized.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No requested items found.</p>';
    return;
  }

  shuffleArray(normalized).forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" onerror="this.style.display='none'">
      <div class="movie-title">${item.title}</div>
    `;
    grid.appendChild(card);
  });

  // Make sure the section is visible (harmless if already visible)
  const section = document.getElementById('wishlistSection');
  if (section) section.style.display = 'block';
}
function loadWishlist() {
  return new Promise(resolve => {
    // Ping (optional but useful to confirm we‚Äôre on the right deployment)
    google.script.run
      .withSuccessHandler(v => console.log('PING (server version):', v))
      .withFailureHandler(err => console.warn('PING failed:', err))
      .pingWishlistVersion();

    // Fetch wishlist from the server
    google.script.run
      .withSuccessHandler(items => {
        renderWishlist(items || []);
        resolve();
      })
      .withFailureHandler(err => {
        console.error('getRequestedWishlist failed:', err);
        renderWishlist([]);
        resolve();
      })
      .getRequestedWishlist();
  });
}

// RECENTLY ADDED
function renderRecentlyAdded(items) {
  const grid = document.getElementById('recentlyAddedGrid');
  grid.innerHTML = '';
  if (!items || items.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No recent videos found.</p>';
    return;
  }

  // Items are already sorted newest ‚Üí oldest by the server
  items.forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" decoding="async">
      <div class="movie-title">${item.title}</div>
    `;
    card.addEventListener('click', () => {
      showEpisodesList(item);
    });
    grid.appendChild(card);
  });
}

function buildRecentlyAddedFragment(items) {
  const frag = document.createDocumentFragment();
  if (!items || !items.length) {
    const p = document.createElement('p');
    p.style.cssText = 'color:#aaa; font-size:24px; text-align:center;';
    p.textContent = 'No recent videos found.';
    frag.appendChild(p);
    return frag;
  }
  items.forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" decoding="async">
      <div class="movie-title">${item.title}</div>
    `;
    card.addEventListener('click', () => showEpisodesList(item));
    frag.appendChild(card);
  });
  return frag;
}

function loadRecentlyAdded() {
  const grid = document.getElementById('recentlyAddedGrid');
  grid.innerHTML = `
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
  `;

  return new Promise(resolve => {
    google.script.run.withSuccessHandler(items => {
      // ‚úÖ cache newest‚Üíoldest for instant reshuffles later
      _recentlyCache.items = Array.isArray(items) ? items : [];
      _recentlyCache.stamp = Date.now();

      renderRecentlyAdded(items);
      resolve();
    }).withFailureHandler(err => {
      console.error("‚ùå Failed to load recently added:", err);
      showPopup("Error loading recently added.");
      resolve();
    }).getRecentVideos(14);
  });
}

function _exploreSetState(rowId, genre, items) {
  // Reset row state with provided items so appendExploreItems() can render from cache
  const st = { genre, items: Array.isArray(items) ? items : [], loaded: 0, loading: false };
  exploreState.set(rowId, st);
  return st;
}

function _exploreRenderFirstBatch(rowEl, rowId, count = 10) {
  rowEl.innerHTML = '';
  appendExploreItems(rowEl, rowId, count);
}

function _arraysDifferById(a = [], b = []) {
  if (a.length !== b.length) return true;
  for (let i = 0; i < a.length; i++) if (a[i]?.id !== b[i]?.id) return true;
  return false;
}

function refreshExploreRowSmooth(rowId, genreId) {
  const rowEl = document.getElementById(rowId);
  if (!rowEl) return Promise.resolve();

  return withSeamlessOverlay(rowEl, async () => {
    // 1) Use prewarmed set instantly if available
    let items = _exploreNextSample.get(rowId) || null;
    if (items && items.length) {
      _exploreNextSample.delete(rowId); // consume
    } else {
      // 2) No prewarm available ‚Üí fetch now
      items = await fetchMixedTopRated(genreId || '', 16);
    }

    if (Array.isArray(items) && items.length) {
      _exploreCache.set(rowId, { genre: genreId || '', items: items.slice(), stamp: Date.now() });
      _exploreSetState(rowId, genreId || '', items);
      _exploreRenderFirstBatch(rowEl, rowId, 10);

      // Keep overlay a touch longer until first posters paint (matches Available feel)
      await waitForImagesToLoad(rowEl, { timeoutMs: 900 });

      // 3) Prewarm the *next* batch in the background
      prewarmExploreRow(rowId, genreId || '', 16);
    }
  });
}

// CONTINUE WATCHING
function loadContinueWatching() {
  if (!currentProfile) {
    console.log("‚ö†Ô∏è No currentProfile, skipping continue watching");
    return Promise.resolve();
  }

  const ensureLibrary = window.library ? Promise.resolve() : loadLibrary();

  return ensureLibrary.then(() =>
    new Promise(resolve => {
      google.script.run
        .withSuccessHandler(data => {
          renderContinueWatching(data || []);
          resolve();
        })
        .withFailureHandler(err => {
          console.error("‚ùå getContinueWatching failed:", err);
          resolve();
        })
        .getContinueWatching(currentProfile);
    })
  );
}

function renderContinueWatching(items) {
  // newest ‚Üí oldest by updatedAt; if missing, they fall to the bottom
  items = (items || []).slice().sort((a, b) => {
    const ta = Date.parse(a.updatedAt || '') || 0;
    const tb = Date.parse(b.updatedAt || '') || 0;
    return tb - ta;
  });

  setCWCache(items || []);
  const container = document.getElementById("continueWatchingGrid");
  if (!container) return;
  container.innerHTML = "";

  if (!items || !Array.isArray(items) || items.length === 0) {
    container.innerHTML = "<p>No titles to continue watching yet.</p>";
    return;
  }

  const library = window.library;
  if (!library) return;

  const normalize = (str) => (str || "").replace(/\u00A0/g, " ").trim().toLowerCase();
  const normCW   = (s)   => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();

  items.forEach((item) => {
    const driveItem = [...(library.movies || []), ...(library.tv || [])].find(
      (lib) => normalize(lib.title) === normalize(item.title)
    );
    if (!driveItem) return;

    const card = document.createElement("div");
    card.className = "movie-card";
    card.style.position = "relative";
    card.dataset.titleNorm = normCW(driveItem.title); // üëà enable upsert/reorder

    card.innerHTML = `
      <img src="${driveItem.poster}" alt="${driveItem.title}" loading="lazy" decoding="async">
      <div class="movie-title">${driveItem.title}</div>
      <button class="cw-complete-btn"
              title="${item.episode ? `Remove \"${driveItem.title}\" ‚Äî \"${item.episode}\" from Continue Watching` : `Remove \"${driveItem.title}\" from Continue Watching`}"
              aria-label="Remove ${driveItem.title} from Continue Watching">‚àí</button>
    `;

    // Open episodes on card click (ignore minus button clicks)
    card.addEventListener("click", (e) => {
      if (e.target && typeof e.target.closest === "function" && e.target.closest(".cw-complete-btn")) return;
      showEpisodesList(driveItem);
    });

    // Minus button removes + broadcasts to other tabs
    const completeBtn = card.querySelector(".cw-complete-btn");
    if (completeBtn) {
      completeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const confirmMsg = item.episode
          ? `Mark "${driveItem.title}" ‚Äî "${item.episode}" as complete?`
          : `Mark "${driveItem.title}" as complete?`;
        if (!window.confirm(confirmMsg)) return;

        // Optimistic: markComplete will remove this card locally
        markComplete(currentProfile, driveItem.title, card, item.episode || "");

        // üîî Broadcast the removal so other tabs update instantly
        try {
          localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
            t: Date.now(),
            action: "remove",
            title: driveItem.title
          }));
        } catch (_) {}
      });
    }

    container.appendChild(card);
  });

  const sec = document.getElementById("continueWatchingSection");
  if (sec) sec.style.display = "block";
}

// DETAILS & TRAILERS
async function fetchTMDbDetails(item, isTV = false) {
  return new Promise(resolve => {
    google.script.run
      .withSuccessHandler(data => {
        if (!data || data.error) {
          const trailerContainer = document.getElementById('tmdbTrailerContainer');
          const titleElem = document.getElementById('tmdbDetailsTitle');
          const dateElem = document.getElementById('tmdbDetailsReleaseDate');
          const overviewElem = document.getElementById('tmdbDetailsOverview');
          const preview = document.getElementById('tmdbDetailsPreview');

          if (trailerContainer) trailerContainer.innerHTML = '<p><em>Details not available for this title.</em></p>';
          if (titleElem) titleElem.textContent = item.title || item.name || 'Unknown';
          if (dateElem) dateElem.innerHTML = '';
          if (overviewElem) overviewElem.textContent = 'We could not load details from TMDb.';
          if (preview) preview.style.display = 'block';
          resolve(null);
          return;
        }
        resolve(data);
      })
      .withFailureHandler(() => {
        resolve(null);
      })
      .getTMDbDetails(item.id, isTV);
  });
}

const GENRES = { 
  comedy:'35', western:'37', action:'28', drama:'18', animation:'16', history:'36', scifi:'878' 
};

// NEW: track if user has revealed the per-genre lists
let _genresRevealed = false;

// NEW: load only the "Explore All" row
async function loadExploreAllRow() {
  const rowId = 'tmdbExploreAllRow';
  const row = document.getElementById(rowId);
  if (!row) return;
  row.classList.add('is-refreshing');
  try {
    await initExploreRow('', rowId); // '' = no genre filter (your ‚ÄúAll‚Äù mixed row)
  } catch (e) {
    console.error('Explore All init failed:', e);
    row.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">Couldn‚Äôt load this list.</p>';
  } finally {
    row.classList.remove('is-refreshing');
  }
}

// Helpers for randomness (if you added these earlier)
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randPage(max = 500) { return randInt(1, max); }

// Per-row lazy-load state for Explore sections
const exploreState = new Map(); // key = rowId, value = { genre, items:[], loaded:0, loading:false }

function _dedupe(items) {
  const seen = new Set();
  return (items || []).filter(it => {
    const key = `${it.id}|${it.media_type || (it.first_air_date ? 'tv' : 'movie')}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

async function initExploreRow(genre, rowId) {
  const rowEl = document.getElementById(rowId);
  if (!rowEl) return;

  // reset state for this row
  exploreState.set(rowId, { genre, items: [], loaded: 0, loading: false });

  // show skeletons (optional)
  rowEl.innerHTML = `
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
  `;

  // prime ~12 items, then render first 10
  const st = await ensureExploreBuffer(rowId, genre, 12);
  rowEl.innerHTML = '';
  appendExploreItems(rowEl, rowId, 10);
  // ‚ùå no infinite scroll

  // Save the initialized set into cache for instant reshuffles later
  if (st && Array.isArray(st.items) && st.items.length) {
    _exploreCache.set(rowId, { genre, items: st.items.slice(), stamp: Date.now() });
  }
}

// Helper to call Apps Script; returns [] on failure
function callScript(fn, ...args) {
  return new Promise(resolve => {
    try {
      google.script.run
        .withSuccessHandler(res => resolve(Array.isArray(res) ? res : []))
        .withFailureHandler(() => resolve([]))[fn](...args);
    } catch (_) {
      resolve([]);
    }
  });
}

// Helpers for randomness
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randPage(max = 500) { return randInt(1, max); }

async function fetchMixedTopRated(genreId, count = 12) {
  const ATTEMPTS = 3;         // how many random-page attempts per step
  const REGION   = 'US';
  const wanted   = Number(genreId || 0);

  let merged = [];

  // 1) Provider-filtered: random pages, multiple attempts
  for (let i = 0; i < ATTEMPTS && merged.length < count; i++) {
    const [m, t] = await Promise.all([
      callScript('getDiscoverByGenreTypeProviders', 'movie', randPage(), REGION, genreId || ''),
      callScript('getDiscoverByGenreTypeProviders', 'tv',    randPage(), REGION, genreId || '')
    ]);
    merged = _dedupe([...merged, ...(m || []), ...(t || [])]);
  }

  // 2) Fallback: genre-only (no provider filter), still random pages
  if (merged.length < count) {
    for (let i = 0; i < ATTEMPTS && merged.length < count; i++) {
      const [m, t] = await Promise.all([
        callScript('getDiscoverByGenreType', 'movie', randPage(), REGION, genreId || ''),
        callScript('getDiscoverByGenreType', 'tv',    randPage(), REGION, genreId || '')
      ]);
      merged = _dedupe([...merged, ...(m || []), ...(t || [])]);
    }
  }

  // 3) (Optional) Last fallback: trending BUT keep genre pure
  //    Remove this whole block if you want strict genre-only.
  if (merged.length < count) {
    const [m2, t2] = await Promise.all([
      callScript('getTrendingByType', 'movie', randPage()),
      callScript('getTrendingByType', 'tv',    randPage())
    ]);
    merged = _dedupe([...merged, ...(m2 || []), ...(t2 || [])])
      .filter(it => Array.isArray(it.genre_ids) && it.genre_ids.includes(wanted));
  }

  // Final: shuffle every time, then cap to `count`
  return shuffleArray(merged).slice(0, count);
}

async function revealAndLoadAllGenres() {
  if (_genresRevealed) return;
  _genresRevealed = true;

  const btnWrap = document.getElementById('revealGenresWrap');
  if (btnWrap) btnWrap.style.display = 'none';

  // Show each genre section title, but keep the row empty
  GENRE_ROWS.forEach(({ sectionId, rowId }) => {
    const sectionEl = document.getElementById(sectionId);
    if (sectionEl) sectionEl.style.display = 'block';

    const rowEl = document.getElementById(rowId);
    if (rowEl) {
      rowEl.classList.remove('is-refreshing');
      rowEl.innerHTML = ''; // ‚Üê titles hidden until user clicks "Show"
    }
  });

  // üî• Prewarm each genre once so the first refresh after "Show" is instant
  prewarmExploreRow('tmdbExploreComedyRow',    GENRES.comedy,    16);
  prewarmExploreRow('tmdbExploreWesternRow',   GENRES.western,   16);
  prewarmExploreRow('tmdbExploreActionRow',    GENRES.action,    16);
  prewarmExploreRow('tmdbExploreDramaRow',     GENRES.drama,     16);
  prewarmExploreRow('tmdbExploreAnimationRow', GENRES.animation, 16);
  prewarmExploreRow('tmdbExploreHistoryRow',   GENRES.history,   16);
  prewarmExploreRow('tmdbExploreScifiRow',     GENRES.scifi,     16);

  // Ensure ‚ÄúShow‚Äù sidebars exist
  attachAllListSidebars();
}

// Make sure we have at least `need` items cached for this row
async function ensureExploreBuffer(rowId, genre, need = 10) {
  let st = exploreState.get(rowId);
  if (!st) {
    st = { genre, items: [], loaded: 0, loading: false };
    exploreState.set(rowId, st);
  }
  const missing = Math.max(0, need - (st.items.length - st.loaded));
  if (missing <= 0) return st;

  if (st.loading) return st; // someone else is fetching
  st.loading = true;
  try {
    // ask for a bit extra to keep things feeling fresh
    const batch = await fetchMixedTopRated(genre, Math.max(12, missing + 8));
    // merge + dedupe by id|type
    const merged = _dedupe([...st.items, ...batch]);
    st.items = merged;
  } finally {
    st.loading = false;
  }
  return st;
}

// Append up to `count` new cards to the row from its cache
function appendExploreItems(rowEl, rowId, count = 5) {
  const st = exploreState.get(rowId);
  if (!st || !st.items.length) return;

  const start = st.loaded;
  const end = Math.min(start + count, st.items.length);
  if (start >= end) return;

  const frag = document.createDocumentFragment();
  for (let i = start; i < end; i++) {
    frag.appendChild(createCard(st.items[i], true, wishlistRequestedTitles));
  }
  rowEl.appendChild(frag);
  st.loaded = end;
}

/* ---- LIST SIDEBAR REFRESH (helpers) ---- */
/**
 * Wrap a scroll container in a two‚Äëcolumn layout and attach a sidebar refresh button.
 * @param {string} gridId  - the list‚Äôs scroll container id
 * @param {Function} onClick - handler to refresh just this list
 * @param {string} [label='Refresh']
 * @param {string} [ariaLabel]
 */
function addSidebarRefresh(gridId, onClick, label = 'Refresh', ariaLabel) {
  const grid = document.getElementById(gridId);
  if (!grid) return null;
  if (grid._sidebarAttached) return grid._sidebarBtn || null;

  const wrapper = document.createElement('div');
  wrapper.className = 'list-row';
  grid.parentNode.insertBefore(wrapper, grid);

  const side = document.createElement('div');
  side.className = 'list-sidebar';
  wrapper.appendChild(side);

  wrapper.appendChild(grid);

  const btn = document.createElement('div');
  btn.className = 'nav-item';
  btn.role = 'button';
  btn.tabIndex = 0;
  btn.setAttribute('aria-label', ariaLabel || `Refresh ${gridId}`);
  btn.innerHTML = `<i class="fa-solid fa-rotate"></i><span>${label}</span>`;
  side.appendChild(btn);

  // dynamic handler we can swap later
  btn._dynamicHandler = onClick;

  let busy = false;
  const doClick = async () => {
    if (busy) return;
    busy = true;
    btn.setAttribute('aria-busy','true');
    try {
      if (typeof btn._dynamicHandler === 'function') {
        await btn._dynamicHandler();
      }
    } finally {
      busy = false;
      btn.removeAttribute('aria-busy');
    }
  };

  btn.addEventListener('click', doClick);
  btn.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); doClick(); }
  });

  grid._sidebarAttached = true;
  grid._sidebarBtn = btn;
  return btn;
}

// Explore ‚Äî All (sidebar button should REFRESH like the others)
addSidebarRefresh(
  'tmdbExploreAllRow',
  async () => {
    if (_currentShownGenre) {
      const prev = document.getElementById(_currentShownGenre.sectionId);
      if (prev) prev.style.display = 'none';
      _currentShownGenre = null;
    }
    const sec = document.getElementById('tmdbExploreAllSection');
    if (sec) sec.style.display = 'block';

    const row = document.getElementById('tmdbExploreAllRow');
    if (row && row.children.length === 0) {
      row.classList.add('is-refreshing');
      try { await initExploreRow('', 'tmdbExploreAllRow'); }
      finally { row.classList.remove('is-refreshing'); }
    }
    await refreshExploreRowSmooth('tmdbExploreAllRow', '');
    sec?.scrollIntoView({ behavior: 'smooth', block: 'start' });
  },
  'Refresh',
  'Refresh Explore All'
);

// Track which genre section is currently shown
let _currentShownGenre = null;

// SINGLE SOURCE OF TRUTH: genre sections/rows
const GENRE_ROWS = [
  { sectionId:'tmdbExploreComedySection',    rowId:'tmdbExploreComedyRow',    genre: GENRES.comedy,    label:'Comedy' },
  { sectionId:'tmdbExploreWesternSection',   rowId:'tmdbExploreWesternRow',   genre: GENRES.western,   label:'Western' },
  { sectionId:'tmdbExploreActionSection',    rowId:'tmdbExploreActionRow',    genre: GENRES.action,    label:'Action' },
  { sectionId:'tmdbExploreDramaSection',     rowId:'tmdbExploreDramaRow',     genre: GENRES.drama,     label:'Drama' },
  { sectionId:'tmdbExploreAnimationSection', rowId:'tmdbExploreAnimationRow', genre: GENRES.animation, label:'Animation' },
  { sectionId:'tmdbExploreHistorySection',   rowId:'tmdbExploreHistoryRow',   genre: GENRES.history,   label:'History' },
  { sectionId:'tmdbExploreScifiSection',     rowId:'tmdbExploreScifiRow',     genre: GENRES.scifi,     label:'Sci-Fi' }
];

// Button visual modes
function setSidebarBtnState(btn, mode = 'show', labelText = 'Show', rowId = '') {
  if (!btn) return;
  if (mode === 'show') {
    btn.innerHTML = `<i class="fa-solid fa-eye"></i><span>Show</span>`;
    btn.setAttribute('aria-label', `Show ${rowId}`);
  } else { // refresh
    btn.innerHTML = `<i class="fa-solid fa-rotate"></i><span>Refresh</span>`;
    btn.setAttribute('aria-label', `Refresh ${rowId}`);
  }
}

// Makes only the chosen genre list populated (others keep their headings but no titles)
async function showOnlyGenre(cfg) {
  // 1) Clear titles (not the headers) for all other genre rows + set their buttons to "Show"
  GENRE_ROWS.forEach(other => {
    if (other.rowId === cfg.rowId) return;
    const grid = document.getElementById(other.rowId);
    if (grid) grid.innerHTML = ''; // hide titles only
    const otherBtn = grid? grid._sidebarBtn : null;
    if (otherBtn) {
      setSidebarBtnState(otherBtn, 'show', 'Show', other.rowId);
      // When in SHOW mode: clicking loads only that list
      otherBtn._dynamicHandler = async () => { await showOnlyGenre(other); };
    }
  });

  // 2) Ensure the chosen row is populated; if empty, load it; if cached, render from cache
  const grid = document.getElementById(cfg.rowId);
  if (!grid) return;

  if (grid.children.length === 0) {
    // First time: init row (fills exploreState + cache)
    await initExploreRow(cfg.genre, cfg.rowId);
  } else {
    // Already has cards; no-op (you wanted it to just be the active one)
  }

  // 3) Switch the chosen button to "Refresh" behavior
  const btn = grid._sidebarBtn;
  if (btn) {
    setSidebarBtnState(btn, 'refresh', 'Refresh', cfg.rowId);
    // When in REFRESH mode: clicking refreshes the active list (smooth)
    btn._dynamicHandler = async () => { await refreshExploreRowSmooth(cfg.rowId, cfg.genre); };
  }
}

/* Map each list to its own refresh action */
function attachAllListSidebars() {

  addSidebarRefresh(
    'availableToWatchGrid',
    async () => {
      await refreshAvailableToWatch({ force: true });   // always pull fresh 10 from Drive
    },
    'Refresh',
    'Refresh Available to Watch'
  );

  // Wishlist
  addSidebarRefresh(
    'wishlistGrid',
    async () => { await loadWishlist(); },
    'Refresh',
    'Refresh Wishlist'
  );

    // Explore ‚Äî All (sidebar button should REFRESH like the others)
    addSidebarRefresh(
      'tmdbExploreAllRow',
      async () => {
        // Hide any shown per-genre section
        if (_currentShownGenre) {
          const prev = document.getElementById(_currentShownGenre.sectionId);
          if (prev) prev.style.display = 'none';
          _currentShownGenre = null;
        }

        // Ensure the section is visible
        const sec = document.getElementById('tmdbExploreAllSection');
        if (sec) sec.style.display = 'block';

        const row = document.getElementById('tmdbExploreAllRow');

        // Init once if empty
        if (row && row.children.length === 0) {
          row.classList.add('is-refreshing');
          try { await initExploreRow('', 'tmdbExploreAllRow'); }
          finally { row.classList.remove('is-refreshing'); }
        }

        // üîÅ Actual refresh
        await refreshExploreRowSmooth('tmdbExploreAllRow', '');
        sec?.scrollIntoView({ behavior: 'smooth', block: 'start' });
      },
      'Refresh',
      'Refresh Explore All'
    );

  const _allBtn = document.getElementById('tmdbExploreAllRow')?._sidebarBtn;
  if (_allBtn) _allBtn._dynamicHandler = async () => {
    const row = document.getElementById('tmdbExploreAllRow');
    if (row && row.children.length === 0) await initExploreRow('', 'tmdbExploreAllRow');
    await refreshExploreRowSmooth('tmdbExploreAllRow', '');
  };

  // Explore All: set button to "Refresh" and force it to actually refresh
  const _exploreAllBtn = document.getElementById('tmdbExploreAllRow')?._sidebarBtn;
  if (_exploreAllBtn) {
    setSidebarBtnState(_exploreAllBtn, 'refresh', 'Refresh', 'tmdbExploreAllRow');
    _exploreAllBtn._dynamicHandler = async () => {
      const row = document.getElementById('tmdbExploreAllRow');
      if (row && row.children.length === 0) await initExploreRow('', 'tmdbExploreAllRow');
      await refreshExploreRowSmooth('tmdbExploreAllRow', '');
    };
  }

  // Explore ‚Äî per-genre rows: use "Show" first
  GENRE_ROWS.forEach(cfg => {
    const btn = addSidebarRefresh(
      cfg.rowId,
      async () => { await showOnlyGenre(cfg); },
      'Show',
      `Show ${cfg.rowId}`
    );
    if (btn) setSidebarBtnState(btn, 'show', 'Show', cfg.rowId);
  });
}

function loadWishlistRequested() {
  // Backward-compatible shim; use ensureWishlistAll internally
  return ensureWishlistAll().then(() => {});
}

function checkStickyShadow() {
  const stickyOffset = 100;  // or your preferred threshold
  const titles = document.querySelectorAll('.section-title, .tmdb-title');
  titles.forEach(el => {
    const rect = el.getBoundingClientRect();
    if (rect.top <= stickyOffset) {
      el.classList.add('sticky-shadow');
    } else {
      el.classList.remove('sticky-shadow');
    }
  });
}

window.addEventListener('scroll', checkStickyShadow);
window.addEventListener('load', checkStickyShadow);

waitForImagesToLoad(document.getElementById('appContent')).then(() => {
});

const exploreBtn = document.getElementById("mobileExploreRefresh");
if (exploreBtn) {
  exploreBtn.addEventListener("click", async () => {
    if (exploreBtn.dataset.busy === "1") return; // debounce
    try {
      exploreBtn.dataset.busy = "1";
      exploreBtn.setAttribute("aria-busy", "true");
      if (_genresRevealed) {
        // Smooth refresh each visible genre row
        await refreshExploreRowSmooth('tmdbExploreComedyRow',    GENRES.comedy);
        await refreshExploreRowSmooth('tmdbExploreWesternRow',   GENRES.western);
        await refreshExploreRowSmooth('tmdbExploreActionRow',    GENRES.action);
        await refreshExploreRowSmooth('tmdbExploreDramaRow',     GENRES.drama);
        await refreshExploreRowSmooth('tmdbExploreAnimationRow', GENRES.animation);
        await refreshExploreRowSmooth('tmdbExploreHistoryRow',   GENRES.history);
        await refreshExploreRowSmooth('tmdbExploreScifiRow',     GENRES.scifi);
      } else {
        // Only the ‚ÄúAll‚Äù row is visible
        await refreshExploreRowSmooth('tmdbExploreAllRow', '');
      }
    console.log("Explore lists refreshed (smooth)");
    } finally {
      exploreBtn.dataset.busy = "0";
      exploreBtn.removeAttribute("aria-busy");
    }
  });
}

// --- Refresh: Available to Watch (always pull fresh 10 from Drive) ---
const availBtn = document.getElementById("mobileAvailableRefresh");
availBtn.addEventListener("click", async () => {
  const grid = document.getElementById('availableToWatchGrid');
  await withSeamlessOverlay(grid, () => refreshAvailableToWatch({ force: true }));
  console.log("Available to Watch reloaded (fresh 10)");
});

let libraryLoaded = false;
</script>
</body>
</html>
