<!DOCTYPE html>

<!--
Rules for ChatGPT chat:
Show before and after snippets for replacement codes
Specify the function a new code should go directly under
Give only one step at a time, confirming the change hasnt broken any codes for the app
-->

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ILYMMD+</title>

  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" as="style">
  <link rel="preload" href="https://i.postimg.cc/HkMtCdMK/ILYMMD-8-4-2025.png" as="image">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" media="all" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"></noscript>
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"></noscript>

<style>
/* =======================
   GLOBAL BASE STYLES
   ======================= */
:root {
  /* spacing & sizes you might tweak later */
}

body {
  font-family: Arial, sans-serif;
  background: #141414;
  color: #fff;
  margin: 0;
  font-size: 60px; /* mobile default */
}

#appContent {
  padding-top: 0;         /* header is static */
  padding-bottom: 120px;  /* make room for bottom bar */
}

/* =======================
   HEADER
   ======================= */
header {
  background: #000;
  box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  text-align: center;
  position: relative;
  z-index: 1;
}
header img {
  max-width: 350px;
  height: auto;
}

/* =======================
   EPISODES (same sizing as titles)
   ======================= */
.active-episode {
  outline: 3px solid #00a7b0;
  outline-offset: 2px;
}

/* NOTE:
   We intentionally DO NOT override width, fonts, or gap inside #episodesSection,
   so episode cards inherit the same .movie-card sizing as titles (mobile & desktop).
   If you previously had compact styles here, they've been removed. */

/* Ensure the trailer area is on top and interactive */
#tmdbTrailerContainer { position: relative; z-index: 1; }

/* Just in case: never disable pointer events on the preview or the container */
#tmdbDetailsPreview, #tmdbTrailerContainer, #tmdbTrailerFrame {
  pointer-events: auto !important;
}

/* =======================
   PROFILES
======================= */

#switchProfileBtn {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
}

#switchProfileBtn img {
  border-radius: 50%; /* circular icon */
}

.profile-btn {
  background: #1f1f1f;
  color: #fff;
  font-size: 30px;
  border: none;
  padding: 20px;
  border-radius: 20px;
  cursor: pointer;
  transition: background 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px; /* space between icon and name */
}

.profile-btn img {
  width: 100px;   /* icon size */
  height: 100px;
  border-radius: 50%; /* round icons */
  object-fit: cover;
}

.profile-btn:hover { 
  background: #00a7b0; 
}

/* =======================
   SEARCH BAR
   ======================= */
.search-bar {
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  height: 55px;
  background: #141414;
  padding: 10px 0;
  text-align: center;
  z-index: 10000;
}
.search-bar input {
  padding: 40px;
  width: 95%;
  max-width: 750px;
  font-size: 60px;
  border-radius: 12px;
  border: none;
}

/* =======================
   SECTION / TITLE HEADERS
   ======================= */
.section-title,
.tmdb-title {
  font-family: 'Roboto', sans-serif;
  font-weight: 700;
  font-size: 90px;
  text-align: center;
  color: #fff;
  position: sticky;
  top: 55px; /* height of search bar */
  background: #141414;
  z-index: 9999;
  padding-top: 30px;
  letter-spacing: 0.05em;
}
.section-title { margin: 80px auto 5px; }
.tmdb-title     { margin: 80px auto 40px; }

.section-title::before,
.tmdb-title::before {
  content: "";
  display: block;
  width: 100px;
  height: 6px;
  background-color: #00a7b0;
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  border-radius: 3px;
}

.subsection-title {
  font-family: 'Roboto', sans-serif;
  font-size: 80px;
  margin: 40px auto 20px;
  padding: 50px 20px 10px;
}

/* =======================
   SCROLL CONTAINERS
   ======================= */
.scroll-container {
  display: flex;
  gap: 30px;
  overflow-x: auto;
  padding: 0 20px 10px;
  position: relative; /* needed for seamless refresh overlay */
}
.scroll-container::-webkit-scrollbar { display: none; }

/* --- Seamless refresh overlay: keep content visible while fetching --- */
.scroll-container.is-refreshing::after {
  content: "";
  position: absolute; inset: 0;
  background: linear-gradient(0deg, rgba(20,20,20,0) 0%, rgba(20,20,20,0.25) 100%);
  pointer-events: none;
  border-radius: 0; /* inherits the container shape */
}
.scroll-container.is-refreshing::before {
  content: "";
  position: absolute; top: 12px; right: 12px;
  width: 18px; height: 18px; border-radius: 50%;
  border: 3px solid #666; border-top-color: #e50914;
  animation: spin .8s linear infinite;
  pointer-events: none;
  z-index: 1;
}

/* =======================
   CARDS & ITEMS
   ======================= */
.movie-card,
.movie-item { border-radius: 12px; cursor: pointer; }

.movie-card {
  background: #1f1f1f;
  overflow: hidden;
  width: 350px;
  flex: 0 0 auto;
  position: relative;
  transition: none !important;

  /* 🔒 keep card height stable while images load */
  aspect-ratio: 2 / 3; 
  display: flex;
  flex-direction: column;
}

.movie-card:hover { transition: none !important; }

.movie-card img,
.movie-item img {
  width: 100%;
  display: block;
  border-radius: 12px;

  /* 🔒 preserve poster box size */
  aspect-ratio: 2 / 3;
  object-fit: cover;
  flex: 1 1 auto;
}

.movie-title {
  padding: 24px;
  text-align: center;
  font-size: 60px;

  /* 🔒 reserve vertical space for the title so row height doesn’t jump */
  min-height: 1.6em;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Add / Request button on TMDb cards */
.add-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: #e50914;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 100px;
  height: 100px;
  font-size: 80px;
  line-height: 96px;
  cursor: pointer;
  z-index: 10;
  transition: background 0.3s ease;
}
.add-btn:hover { background: #ff4c4c; }

/* === Highlight: Recently Added === */
#recentlyAddedSection .subsection-title {
  position: relative;
}
#recentlyAddedSection .subsection-title::after {
  content: "★ fresh drops";
  font-size: 0.6em;
  font-weight: 700;
  color: #00e5ff;
  margin-left: 12px;
  letter-spacing: .04em;
  vertical-align: middle;
}

#recentlyAddedGrid .movie-card {
  border: 2px solid rgba(0, 229, 255, 0.55);
  box-shadow:
    0 0 0 2px rgba(0, 229, 255, 0.15) inset,
    0 0 24px rgba(0, 229, 255, 0.2);
}

#recentlyAddedGrid .movie-card::before {
  content: "NEW";
  position: absolute;
  top: 8px;
  left: -36px;
  transform: rotate(-45deg);
  background: linear-gradient(90deg, #00a7b0, #00e5ff);
  color: #0b0b0b;
  font-weight: 700;
  font-size: 12px;
  padding: 6px 48px;
  letter-spacing: .08em;
  box-shadow: 0 2px 8px rgba(0,0,0,.4);
  z-index: 3;
  border-radius: 2px;
}

/* Hover lift only on Recently Added */
@media (hover: hover) and (pointer: fine) {
  #recentlyAddedGrid .movie-card:hover {
    transform: translateY(-2px);
    box-shadow:
      0 0 0 2px rgba(0, 229, 255, 0.25) inset,
      0 8px 26px rgba(0, 229, 255, 0.28);
  }
}

/* Ribbon text scaling */
@media (max-width: 999px) {
  #recentlyAddedGrid .movie-card::before { font-size: 24px; padding: 10px 70px; left: -60px; top: 12px; }
}
@media (min-width: 1000px) {
  #recentlyAddedGrid .movie-card::before { font-size: 10px; padding: 5px 42px; left: -32px; top: 6px; }
}


/* =======================
   SKELETON LOADER
   ======================= */
.skeleton-card {
  width: 350px;
  height: 450px;
  background: #2c2c2c;
  border-radius: 12px;
  animation: pulse 1.2s infinite;
}
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.6} }

/* =======================
   LOADING OVERLAY
   ======================= */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: #141414;
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  font-family: 'Roboto', sans-serif;
  font-size: 60px;
  z-index: 2147483647;
}

.loader {
  border: 12px solid #333;
  border-top: 12px solid #e50914;
  border-radius: 50%;
  width: 80px;
  height: 80px;
  animation: spin 1s linear infinite;
}
@keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

/* Inline loading label used next to buttons */
.loading-text {
  display: none;             /* hidden by default */
  font-weight: bold;
  color: #e50914;
  vertical-align: middle;
  margin-left: 8px;
  font-size: 24px;           /* base size, overridden in media queries */
}
.add-refresh-btn.loading + .loading-text { display: inline; }

/* Base style for the remove (–) button */
.cw-complete-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 28px;
  height: 28px;
  font-size: 18px;
  line-height: 1;
  border: none;
  border-radius: 50%;
  background-color: rgba(0,0,0,0.7);
  color: white;
  cursor: pointer;
  z-index: 3;
}

.cw-complete-btn:hover {
  transform: scale(1.06);
  background: #ff4c4c; /* brighter red on hover */
}

.cw-complete-btn:disabled {
  opacity: .6;
  cursor: default;
}

/* =======================
   NAV / BOTTOM BAR
   ======================= */
.bottom-bar {
  position: fixed;
  bottom: 0; left: 0;
  width: 100%;
  background: #000;
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  border-top: 1px solid #222;
  z-index: 9999;
}
.nav-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  color: #fff;
  font-size: 40px;
  cursor: pointer;
}
.nav-item i { font-size: 56px; margin-bottom: 8px; }
.nav-item:hover { color: #aaa; }

/* Refresh emoji (used in a few places) */
.refresh-emoji {
  cursor: pointer;
  user-select: none;
  font-size: 30px;           /* overridden in media queries */
  margin-left: 10px;
  vertical-align: middle;
  display: inline-block;
  transition: color 0.3s ease;
}
.refresh-emoji:hover,
.refresh-emoji:focus { color: #ff4c4c; outline: none; }
.refresh-emoji[aria-disabled="true"] {
  color: gray;
  cursor: default;
  pointer-events: none;
}

/* Episodes row controls */
.episodes-close {
  font-size: 0.9em;
  margin-left: 12px;
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  background: #333;
  color: #fff;
  cursor: pointer;
}
.episodes-close:hover { background: #444; }

/* =======================
   MODALS
   ======================= */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.95);
  justify-content: center;
  align-items: center;
  z-index: 2147483646;
  padding: 0;
}
.modal.active { display: flex !important; }

.modal-content {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 95vw;
  max-height: 80vh;
  background: #1f1f1f;
  overflow: hidden;
  border-radius: 12px;
}

/* =======================
   TEXT IN MODAL
   ======================= */
.movie-title-text {
  font-family: 'Roboto', sans-serif;
  font-weight: 700;
  font-size: 70px;
  margin-bottom: 30px;
  color: #fff;
  text-transform: uppercase;
}
.movie-overview {
  font-size: 40px !important;
  line-height: 1.8;
  color: #aaa;
  margin-bottom: 40px;
}

/* =======================
   POPUP & PROMPTS
   ======================= */
#customPopup {
  display: none;
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: #222;
  color: #fff;
  padding: 30px 50px;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.8);
  font-size: 28px;
  z-index: 2147483646 !important;
  max-width: 90vw;
  text-align: center;
  width: 500px;
  box-sizing: border-box;
}

/* === Inline Prompt (non-blocking) === */
#inlinePromptHost {
  position: fixed;
  left: 0; right: 0; bottom: calc(60px + 12px); /* sit above bottom bar */
  display: flex;
  justify-content: center;
  z-index: 2147483646;
  pointer-events: none; /* allow clicks through except the prompt itself */
}

.inline-prompt {
  pointer-events: auto;
  background: #222;
  color: #fff;
  padding: 12px 16px;
  border-radius: 12px;
  box-shadow: 0 6px 30px rgba(0,0,0,.5);
  font-size: 0.9em;
  display: flex;
  align-items: center;
  gap: 12px;
  max-width: min(92vw, 720px);
}

.inline-prompt .prompt-text {
  line-height: 1.4;
}

.inline-prompt .prompt-actions {
  margin-left: auto;
  display: flex;
  gap: 8px;
}

.inline-prompt .prompt-btn {
  border: none;
  border-radius: 10px;
  background: #00a7b0;
  color: #fff;
  padding: 8px 12px;
  font-size: 1em;
  cursor: pointer;
}
.inline-prompt .prompt-btn:hover { background: #00bfc9; }

/* =======================
   MISC
   ======================= */
.sticky-shadow {
  box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  transition: box-shadow 0.3s ease;
}

.movie-card.last-watched {
  position: relative; /* ensure overlay anchors correctly */
}

.movie-card.last-watched::after {
  content: "Last watched";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  text-align: center;
  background: rgba(0, 167, 176, 0.92);
  color: #fff;
  font-weight: normal;
  padding: 14px 16px;
  border-radius: 12px 12px 0 0;
  z-index: 2;
  pointer-events: none;
  font-size: 15px;
}

/* Inline title actions (Show/Refresh next to the title) */
.title-action {
  display: inline-flex;
  align-items: center;
  gap: 0.5em;         
  margin-right: 0.75em;
  vertical-align: middle;
  cursor: pointer;
  user-select: none;
  background-color: #00a7b0;
  color: #fff;
  font-size: 1rem;     
  padding: 0.25em 0.5em; 
  border-radius: 0.4em; 
  border: none;
  outline: none;
  box-shadow: none;
}
.title-action i {
  font-size: 1.4em;   /* make the icon stand out more */
  line-height: 1;
}
.title-action span {
  display: none;
}


/* =======================
   RESPONSIVE: MOBILE
   ======================= */
@media (max-width: 999px) {
  body { font-size: 30px !important; }

  #mobileRefreshButtonsContainer {
    display: flex !important;
    gap: 20px;
    justify-content: center;
    align-items: center;
  }

  .profile-btn img {
    width: 150px;
    height: 150px;
  }

  .movie-card.last-watched::after {
    font-size: 40px;        /* larger text for mobile */
    padding: 14px 16px;     /* taller banner for readability */
  }

  .cw-complete-btn {
    width: 100px !important;
    height: 100px !important;
    font-size: 80px !important;
    line-height: 96px !important;
  }

  #loadingScreen { font-size: 60px !important; }
  header img { max-width: 350px !important; }
  .search-bar input { font-size: 40px !important; }

  .section-title,
  .tmdb-title { box-shadow: none; transition: box-shadow 0.3s ease; }

  .sticky-shadow { box-shadow: 0 2px 5px rgba(0,0,0,0.7); }

  .title-action {
    font-size: 2rem;           /* scale up */
    padding: 0.5em;            /* big hit area */
    border-radius: 0.6em;      /* rounded pill */
    background: #00a7b0;       /* teal fill */
    color: #fff;
    border: none;
    outline: none;
    box-shadow: none;
  }
  .title-action i {
    font-size: 1.6em;         /* bigger icon */
  }
  .title-action span {
    display: none;            /* keep icon-only, less clutter */
  }

  .section-title,
  .tmdb-title {
    font-size: 55px !important;
    margin: 60px auto 40px auto !important;
    padding-top: 24px !important;
    position: sticky !important;
    top: 55px !important;
    background: #141414 !important;
    z-index: 9999 !important;
  }
  .section-title { margin-bottom: 5px !important; }

  .section-title::before,
  .tmdb-title::before { width: 80px !important; height: 5px !important; }

  .subsection-title {
    font-size: 40px !important;
    padding: 30px 20px 10px;
  }

  .movie-card { width: 350px !important; }
  .movie-title { font-size: 40px !important; padding: 24px !important; }
  .skeleton-card { width: 350px !important; height: 450px !important; }

  .modal-content {
    flex-direction: column !important;
    max-width: 95vw !important;
    max-height: 80vh !important;
  }
  #videoFrameContainer { flex: 1 1 100% !important; min-height: 300px !important; width: 100% !important; }
  .movie-info-scroll { flex: 1 1 100% !important; width: 100% !important; padding: 30px !important; }
  .scroll-container { -webkit-overflow-scrolling: touch; /* smoother iOS scrolling */ }

  .refresh-emoji { font-size: 50px; }

  .movie-title-text { font-size: 70px !important; margin-bottom: 30px !important; }
  .movie-rating { font-size: 20px !important; margin-bottom: 20px !important; }
  .movie-overview { font-size: 30px !important; margin-bottom: 40px !important; }

  .loading-text { font-size: 40px !important; }

  .add-btn {
    width: 100px !important;
    height: 100px !important;
    font-size: 80px !important;
    line-height: 96px !important;
  }

  #customPopup {
    width: 90vw;
    padding: 40px 30px;
    font-size: 50px !important;
    top: 15%;
  }
  #popupCloseBtn { font-size: 50px !important; padding: 14px 40px; }

  #inlinePromptHost { bottom: calc(100px + 16px); } /* more room above big mobile bar */
  .inline-prompt { font-size: 1.1em; }
}

/* =======================
   RESPONSIVE: DESKTOP
   ======================= */
@media (min-width: 1000px) {
  body { font-size: 15px !important; }
  #loadingScreen { font-size: 20px !important; }
  header img { max-width: 150px !important; }
  .search-bar input { padding: 10px !important; font-size: 20px !important; }

  .nav-item { font-size: 15px !important; }
  .nav-item i { font-size: 20px !important; }

  .add-btn {
    width: 40px !important;
    height: 40px !important;
    font-size: 20px !important;
    line-height: 36px !important;
  }

  .refresh-emoji { font-size: 25px; }

  .loading-text { font-size: 15px !important; }

  #mobileRefreshButtonsContainer {
    display: flex !important;
    width: 100%;
    justify-content: space-around;
    align-items: center;
  }

  .section-title,
  .tmdb-title {
    font-size: 35px !important;
    margin: 40px auto 20px auto !important;
    padding-top: 12px !important;
    position: sticky !important;
    top: 55px !important;
    background: #141414 !important;
    z-index: 9999 !important;
  }
  .section-title { margin-bottom: 5px !important; }

  .section-title::before,
  .tmdb-title::before { width: 60px !important; height: 4px !important; }

  .subsection-title {
    margin: 0 !important;
    font-size: 20px !important;
    padding: 30px 20px 10px;
  }

  .movie-title { font-size: 15px !important; padding: 4px !important; }
  .movie-card { width: 150px !important; }
  .movie-card:hover { transform: none !important; }
  .skeleton-card { width: 150px !important; height: 200px !important; }

  .movie-info-scroll { padding: 10px !important; }
  .movie-title-text { font-size: 20px !important; margin-bottom: 10px !important; }
  .movie-rating { font-size: 15px !important; margin-bottom: 5px !important; }
  .movie-overview { font-size: 15px !important; margin-bottom: 10px !important; }

  .modal-content { max-width: 90vw !important; max-height: 70vh !important; }
  #videoFrameContainer { min-height: 150px !important; }

  /* visible scrollbars for desktop */
  .scroll-container { scrollbar-width: thin; scrollbar-color: #888 #1f1f1f; }
  .scroll-container::-webkit-scrollbar { height: 12px; }
  .scroll-container::-webkit-scrollbar-track { background: #1f1f1f; border-radius: 6px; }
  .scroll-container::-webkit-scrollbar-thumb { background: #888; border-radius: 6px; }
  .scroll-container::-webkit-scrollbar-thumb:hover { background: #aaa; }
}

/* Disable hover scaling on touch devices */
@media (hover: none) and (pointer: coarse) {
  .movie-card:hover {
    transform: none !important;
  }
}

/* Keep the nice hover scale on real-hover devices (mice/trackpads) */
@media (hover: hover) and (pointer: fine) {
  .movie-card:hover {
    transform: none !important;
  }
}
</style>
</head>
<body>

<div id="profileModal" class="modal active" role="dialog" aria-modal="true">
  <div class="modal-content" style="align-items:center; justify-content:center; text-align:center; padding: 50px;">
    <h2 style="font-size: 60px; margin-bottom: 40px;">Who's watching?</h2>
    <div id="profileList" style="display: flex; gap: 40px; flex-wrap: wrap; justify-content: center;">    
      <button class="profile-btn" data-profile="Dave">
        <img src="https://i.postimg.cc/nVvJZm7y/dave.png" alt="Dave">
        <span>Dave</span>
      </button>    
      <button class="profile-btn" data-profile="Melissa">
        <img src="https://i.postimg.cc/htGW93wn/melissa.png" alt="Melissa">
        <span>Melissa</span>
      </button>
    
      <button class="profile-btn" data-profile="Ben">
        <img src="https://i.postimg.cc/D0K3LfVp/ben.jpg" alt="Ben">
        <span>Ben</span>
      </button>      
      <button class="profile-btn" data-profile="Kassandra">
        <img src="https://i.postimg.cc/Fzg5ZtNr/kassandra.jpg" alt="Kassandra">
        <span>Kassandra</span>
      </button>     
      <button class="profile-btn" data-profile="Aiden">
        <img src="https://i.postimg.cc/JhvL7cpL/aiden.png" alt="Aiden">
        <span>Aiden</span>
      </button>
      <button class="profile-btn" data-profile="Liadan">
        <img src="https://i.postimg.cc/RZbrGL5H/liadan.png" alt="Liadan">
        <span>Liadan</span>
      </button>
    </div>
  </div>
</div>

<div id="appContent" style="display: none;">

  <!-- ========= START: Top Nav Bar ========= -->
    <!-- App Content -->
    <header><br><br><img src="https://i.postimg.cc/HkMtCdMK/ILYMMD-8-4-2025.png" alt="ILYMMD+ Logo"><br><br></header>
    <div class="search-bar"><input type="text" id="searchInput" placeholder="Search movies or shows..."></div>
  <!-- ========= END: Top Nav Bar ========= -->

  <!-- ========= START: Available-to-Watch Group ========= -->
    <!-- TMDb Details Preview -->
    <div id="tmdbDetailsPreview" style="max-width: 900px; margin: 20px auto; background: #1f1f1f; border-radius: 12px; padding: 20px; color: white; display:none;">
      <div id="tmdbTrailerContainer" style="width: 100%; height: 450px; margin-bottom: 20px;"></div>
      <h2 class="movie-title-text" id="tmdbDetailsTitle"></h2>
      <p id="tmdbDetailsReleaseDate"></p>
      <p class="movie-overview" id="tmdbDetailsOverview"></p>

      <!-- NEW: Context-aware action button (Watch Now / Add to Wishlist) -->
      <div style="display:flex; justify-content:center; margin-top: 20px;">
        <button id="tmdbWatchNowBtn"
                type="button"
                aria-label="Watch Now"
                style="background:#00a7b0;border:none;border-radius:12px;padding:14px 22px;color:#fff;font-size:1em;cursor:pointer;">
          Watch Now
        </button>
      </div>
    </div>
    <!-- Recently Added Section -->
    <div id="recentlyAddedSection">
      <h2 class="subsection-title">Recently Added!</h2>
      <div class="scroll-container" id="recentlyAddedGrid">
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
      </div>
    </div><br><br>
    <!-- Watch Header -->
    <h2 class="section-title">Available to Watch</h2>
    <!-- Episodes -->
    <div id="episodesSection" style="display:none;">
      <h2 class="subsection-title" id="episodesTitle"></h2>
      <div class="scroll-container" id="episodesGrid">
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
      </div>
    </div>
    <!-- Continue Watching Section -->
    <div id="continueWatchingSection">
      <h2 class="subsection-title">Continue Watching</h2>
      <div class="scroll-container" id="continueWatchingGrid">
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
      </div>
    </div>
    <!-- All Available Section -->
    <div id="availableToWatchSection">
      <h2 class="subsection-title">All Available Movies & TV Shows</h2>
      <!-- Placeholders while loading -->
      <div class="scroll-container" id="availableToWatchGrid">
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
      </div>
    </div>
    <!-- View by Genre button -->
    <div style="text-align:center; margin: 30px 0;">
      <button id="viewByGenreBtn"
              style="background:#00a7b0;border:none;border-radius:12px;
                    padding:14px 22px;color:#fff;font-size:1em;cursor:pointer;">
        View Available Movies & TV Shows by Genre
      </button>
    </div>
    <!-- Available by Genre (hidden by default) -->
    <div id="myGenresSection" style="display:none;">
      <div id="myGenresWrap"></div>
    </div>
    <!-- Explore Lists -->
    <div id="tmdbExploreAllSection">
      <h2 class="subsection-title">Add to Wishlist</h2>
      <div class="scroll-container" id="tmdbExploreAllRow"></div>
    </div>
    <div id="wishlistSection">
      <h2 class="subsection-title">Wishlist</h2>
      <div class="scroll-container" id="wishlistGrid">
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
        <div class="skeleton-card"></div>
      </div>
    </div>


    <!-- Search Results -->
    <div id="searchResultsSection" style="display:none;">
      <h2 class="subsection-title">Search Results</h2>
      <div class="scroll-container" id="searchResultsGrid"></div>
    </div>
    <!-- Custom Popup -->
    <div id="customPopup" role="status" aria-live="polite" aria-atomic="true" style="display:none; position: fixed; top: 20%; left: 50%; transform: translateX(-50%); background: #222; color: white; padding: 30px 50px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.8); font-size: 28px; z-index: 3000; max-width: 90vw; text-align: center;">
      <span id="popupMessage"></span>
      <button id="popupCloseBtn" style="display:block; margin: 20px auto 0 auto; padding: 10px 30px; font-size: 24px; border: none; border-radius: 8px; background: #e50914; color: white; cursor: pointer;">Close</button>
    </div>
    <!-- Bottom navigation Bar -->
    <div class="bottom-bar">
      <div id="mobileRefreshButtonsContainer" style="display:none; width: 100%; justify-content: center;">
      <div class="nav-item" id="switchProfileBtn" role="button" tabindex="0" aria-label="Switch Profile">
        <img id="currentProfileIcon" alt="Profile" style="display:none;width:50px;height:50px;object-fit:cover;border-radius:50%;margin-bottom:5px;">
        <span id="currentProfileName">Profile</span>
      </div>
    </div>
    </div><br><br>

</div>

<div id="loadingScreen" style="
  font-family: 'Roboto', sans-serif;
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  color: white;
  font-size: 48px;
  align-items: center;
  justify-content: center;
  z-index: 2147483647;
  pointer-events: auto; /* blocks clicks while visible */
  cursor: wait;
">
  Loading...
</div>

<script>
let fullLibrary = [];
let wishlistAvailableTitles = [];
let wishlistRequestedTitles = [];
let _recentlyCache = { items: [], stamp: 0 };
let _exploreCache = new Map();
let _nextAvailableSample = null;
let _hadSavedProfileAtLoad = false;
const _exploreNextSample = new Map();

let _cwPollTimer = null;
function startCWLiveSync() {
  if (_cwPollTimer) clearInterval(_cwPollTimer);
  _cwPollTimer = setInterval(() => {
    if (document.hidden) return; // pause when not visible
    loadContinueWatching();      // cheap refresh
  }, 60000); // 60s
}

/* ===== Group visibility helpers (updated) ===== */
const AVAILABLE_SECTIONS = [
  "continueWatchingSection",
  "recentlyAddedSection",
  "availableToWatchSection"
];

const EXPLORE_SECTIONS = [
  "tmdbExploreAllSection",
  "tmdbExploreComedySection",
  "tmdbExploreWesternSection",
  "tmdbExploreActionSection",
  "tmdbExploreDramaSection",
  "tmdbExploreAnimationSection",
  "tmdbExploreHistorySection",
  "tmdbExploreScifiSection", // (keep correct id spelling if needed)
  "wishlistSection"
];

function _setDisplay(ids = [], value = "block") {
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = value;
  });
}

let _activeGroup = "all"; // unified view

// NEW: single-source-of-truth — show everything together
function showAllSections() {
  _activeGroup = "all";
  _setDisplay(AVAILABLE_SECTIONS, "block");
  _setDisplay(EXPLORE_SECTIONS, "block");

  // show both headers
  const availHeader = document.querySelector(".section-title"); // "Available to Watch"
  const tmdbHeader  = document.querySelector(".tmdb-title");    // "Explore"
  if (availHeader) availHeader.style.display = "block";
  if (tmdbHeader)  tmdbHeader.style.display  = "block";
}

// Make old toggles no-ops that now just show everything
function showAvailableGroup() { showAllSections(); }
function showExploreGroup()   { showAllSections(); }

let _wishlistAllCachePromise;
function ensureWishlistAll() {
  if (!_wishlistAllCachePromise) {
    _wishlistAllCachePromise = new Promise(res => {
      google.script.run
        .withSuccessHandler(items => {
          items = items || [];
          const norm = s => String(s || '').trim().toLowerCase();
          wishlistRequestedTitles = items.filter(x => norm(x.status) === "wishlist");
          wishlistAvailableTitles = items.filter(x => norm(x.status) === "available");
          res(items);
        })
        .withFailureHandler(() => res([]))
        .getWishlistAllWithStatus();
    });
  }
  return _wishlistAllCachePromise;
}

const appContent = document.getElementById('appContent');

let _lastFocus = null;

// Place directly under the existing helper declarations (same location as before)
function selectProfile(profileName, iconUrl) {
  // Show loader over the modal first
  loadingScreen.style.display = "flex"; // overlays modal

  // Set current profile
  currentProfile = profileName;

  // Persist selection for this browser (safe/no-op if blocked)
  try {
    localStorage.setItem("lastProfileName", String(profileName || ""));
    localStorage.setItem("lastProfileIcon", String(iconUrl || "https://via.placeholder.com/50"));
  } catch (_) {}

  // Update bottom bar button
  const nameEl = document.getElementById("currentProfileName");
  const iconEl = document.getElementById("currentProfileIcon");
  if (nameEl) nameEl.textContent = currentProfile || "Profile";
  if (iconEl) {
    iconEl.src = iconUrl || "https://via.placeholder.com/50";
    iconEl.style.display = "inline-block";
  }

  // Hide modal, keep app visible under loader
  const profileModal = document.getElementById("profileModal");
  const app = document.getElementById("appContent");
  profileModal.classList.remove("active");
  app.style.display = "block";

  // Load CW first; hide loader as soon as CW is ready
  loadContinueWatching()
    .then(() => {
      const cw = document.getElementById("continueWatchingSection");
      if (cw) cw.style.display = "block";
      hideLoadingScreen(0);
      startCWLiveSync(); // 60s polling fallback

      // ✅ Make Available visible and keep Explore hidden
      showAvailableGroup();
    })
    .catch(err => {
      console.error("❌ Error loading Continue Watching:", err);
      hideLoadingScreen(0);
      startCWLiveSync();
    });

  // Ensure wishlist cache once, then load Wishlist
  ensureWishlistAll()
    .then(() => Promise.all([ loadWishlist() ]))
    .then(() => {
      // Do NOT force wishlist visible here — group toggles control it.
      const ra = document.getElementById("recentlyAddedSection");
      if (ra) ra.style.display = "block";
      return waitForImagesToLoad(app, { timeoutMs: 2500 });
    })
    .catch(err => {
      console.error("❌ Error during background loads:", err);
      showPopup("Some items are still loading. Try again if they don't appear.");
    });
}

function showPopup(messageHtml) {
  _lastFocus = document.activeElement;
  const popup = document.getElementById('customPopup');
  const msgSpan = document.getElementById('popupMessage');
  msgSpan.innerHTML = messageHtml;
  popup.style.display = 'block';
  document.getElementById('popupCloseBtn').focus();
}

document.getElementById('popupCloseBtn').addEventListener('click', () => {
  document.getElementById('customPopup').style.display = 'none';
  if (_lastFocus && typeof _lastFocus.focus === 'function') {
    _lastFocus.focus();
  }
});

document.addEventListener('keydown', (e) => {
  const popup = document.getElementById('customPopup');
  if (e.key === 'Escape' && popup.style.display === 'block') {
    document.getElementById('popupCloseBtn').click();
  }
});

(function initInlinePromptHost(){
  if (!document.getElementById('inlinePromptHost')) {
    const host = document.createElement('div');
    host.id = 'inlinePromptHost';
    document.body.appendChild(host);
  }
})();

/**
 * showPrompt({ text, actions: [{label, onClick(close)}], timeoutMs })
 * - Returns a controller { close() } in case you want to close it manually.
 */
function showPrompt(opts) {
  const { text = '', actions = [], timeoutMs = 5000 } = opts || {};
  const host = document.getElementById('inlinePromptHost');
  if (!host) return { close(){} };

  // Replace any existing prompt (singleton UX)
  host.innerHTML = '';

  const wrap = document.createElement('div');
  wrap.className = 'inline-prompt';
  wrap.setAttribute('role', 'status');
  wrap.setAttribute('aria-live', 'polite');

  const msg = document.createElement('div');
  msg.className = 'prompt-text';
  msg.textContent = text;

  const btns = document.createElement('div');
  btns.className = 'prompt-actions';

  const close = () => {
    if (wrap && wrap.parentNode) {
      wrap.parentNode.removeChild(wrap);
    }
  };

  // Build action buttons
  (actions.length ? actions : [{ label: 'OK' }]).forEach(a => {
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'prompt-btn';
    b.textContent = a.label || 'OK';
    b.addEventListener('click', () => {
      try { a.onClick && a.onClick(close); } finally { if (!a.onClick) close(); }
    });
    btns.appendChild(b);
  });

  wrap.appendChild(msg);
  wrap.appendChild(btns);
  host.appendChild(wrap);

  // Auto-dismiss
  if (timeoutMs > 0) {
    setTimeout(() => { close(); }, timeoutMs);
  }

  return { close };
}

// Remove an item from Continue Watching for this profile
function markComplete(profile, title, cardEl, episode = "") {
  if (!profile || !title) return;

  // Optimistic UI: disable button + fade card a bit
  const btn = cardEl.querySelector('.cw-complete-btn');
  if (btn) btn.disabled = true;
  cardEl.style.opacity = '0.6';

  google.script.run
  .withSuccessHandler(res => {
    // Keep info to allow undo
    const removedTitle   = title;
    const removedEpisode = episode || "";

    // Remove the card from the UI
    cardEl.remove();

    // If the row goes empty, show the empty state
    const container = document.getElementById("continueWatchingGrid");
    if (container && container.children.length === 0) {
      container.innerHTML = "<p>No titles to continue watching yet.</p>";
    }

    // 🔔 Non-blocking prompt with Undo
    showPrompt({
      text: `Removed “${removedTitle}” from Continue Watching.`,
      actions: [
        {
          label: "Undo",
          onClick: async (close) => {
            // Put the card back at the top immediately
            upsertContinueWatchingCard(removedTitle, removedEpisode);

            // Persist progress back (best-effort)
            try {
              await new Promise(resolve => {
                google.script.run
                  .withSuccessHandler(resolve)
                  .withFailureHandler(resolve) // don't block UI on failure
                  .saveProfileProgress(currentProfile, removedTitle, removedEpisode);
              });
            } catch (_) {}

            // Let other tabs know
            try {
              localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
                t: Date.now(), action: "upsert", title: removedTitle, episode: removedEpisode
              }));
            } catch (_) {}

            // Close the prompt
            close();
          }
        }
      ],
      // auto-hide after 6s if user ignores it
      timeoutMs: 6000
    });
  })
  .withFailureHandler(err => {
    // Roll back UI on error
    if (btn) btn.disabled = false;
    cardEl.style.opacity = '1';

    // Use the same prompt style for errors (no modal)
    showPrompt({
      text: `Couldn't remove “${title}”. ${err?.message || "Please try again."}`,
      actions: [{ label: "Dismiss" }],
      timeoutMs: 6000
    });
  })
  .clearProfileProgress(profile, title);
}

// Normalize for CW keys / lookups
const _normCW = s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();

/** Build one CW card (matches renderContinueWatching look & behavior) */
function makeCWCard(driveItem, episode = "") {
  const card = document.createElement("div");
  card.className = "movie-card";
  card.style.position = "relative";
  card.dataset.titleNorm = _normCW(driveItem.title);
  card.innerHTML = `
    <img src="${driveItem.poster}" alt="${driveItem.title}" loading="lazy" decoding="async">
    <div class="movie-title">${driveItem.title}</div>
    <button class="cw-complete-btn" title="Remove from Continue Watching" aria-label="Remove ${driveItem.title} from Continue Watching">−</button>
  `;

  // open episodes on card click (but not when clicking the minus)
  card.addEventListener("click", (e) => {
    if (e.target && typeof e.target.closest === "function" && e.target.closest(".cw-complete-btn")) return;
    // show the episodes list
    const local = findLocalByTitle(driveItem.title);
    if (local) showEpisodesList(local);
  });

  // minus button wiring
  const btn = card.querySelector(".cw-complete-btn");
  if (btn) {
    btn.addEventListener("click", (e) => {
      e.stopPropagation();
      const confirmMsg = episode
        ? `Mark "${driveItem.title}" — "${episode}" as complete?`
        : `Mark "${driveItem.title}" as complete?`;
      if (!window.confirm(confirmMsg)) return;
      markComplete(currentProfile, driveItem.title, card, episode || "");
      // 🔔 broadcast removal to other tabs
      try {
        localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
          t: Date.now(), action: "remove", title: driveItem.title
        }));
      } catch(_) {}
    });
  }
  return card;
}

/** Upsert a CW card at the top (instant UI update) */
function upsertContinueWatchingCard(title, episode = "") {
  const grid = document.getElementById("continueWatchingGrid");
  if (!grid || !window.library) return;

  // find matching item in your library
  const local = findLocalByTitle(title);
  if (!local) return;

  const key = _normCW(title);

  // if empty state text is there, clear it
  if (!grid.querySelector(".movie-card") && grid.textContent.includes("No titles to continue watching")) {
    grid.innerHTML = "";
  }

  // Look for existing card
  let card = Array.from(grid.children).find(el => el.dataset?.titleNorm === key);

  if (card) {
    // move to top and update button episode context
    grid.insertBefore(card, grid.firstChild);
    const minus = card.querySelector(".cw-complete-btn");
    if (minus) {
      minus.title = episode
        ? `Remove "${title}" — "${episode}" from Continue Watching`
        : `Remove "${title}" from Continue Watching`;
    }
  } else {
    // create new card and prepend
    const newCard = makeCWCard(local, episode);
    grid.insertBefore(newCard, grid.firstChild);
  }

  // ensure section visible
  const section = document.getElementById("continueWatchingSection");
  if (section) section.style.display = "block";

  // keep the in-memory cache aligned so last-watched highlighting works
  cwProgressByTitle.set(_norm(title), String(episode || ""));
  try { localStorage.setItem(`lastWatched_${_norm(title)}`, String(episode || "")); } catch(_) {}

  // 🔔 broadcast upsert to other tabs
  try {
    localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
      t: Date.now(), action: "upsert", title, episode
    }));
  } catch(_) {}
}

function waitForImagesToLoad(container, { timeoutMs = 2500 } = {}) {
  // Fast‑path: if container missing, resolve immediately
  if (!container) return Promise.resolve();

  const images = Array.from(container.querySelectorAll("img"));

  // Fast‑path: nothing to wait on
  if (images.length === 0) return Promise.resolve();

  const inViewport = el => {
    const r = el.getBoundingClientRect();
    return r.top < window.innerHeight && r.bottom > 0 && r.left < window.innerWidth && r.right > 0;
  };

  const promises = images.map(img => {
    // Already loaded (covers cached images and ones with naturalWidth > 0)
    if (img.complete || img.naturalWidth > 0) return Promise.resolve();

    // If it's lazy and off‑screen, don't block the loader on it
    const isLazy = img.loading === 'lazy' || img.getAttribute('loading') === 'lazy';
    if (isLazy && !inViewport(img)) return Promise.resolve();

    // Otherwise, wait for load/error
    return new Promise(resolve => {
      const done = () => { img.onload = img.onerror = null; resolve(); };
      img.onload = done;
      img.onerror = done;
    });
  });

  const timeout = new Promise(res => setTimeout(res, timeoutMs));
  return Promise.race([Promise.all(promises), timeout]);
}

function withSeamlessOverlay(el, fn) {
  if (!el) return fn();
  el.classList.add('is-refreshing');
  return Promise.resolve()
    .then(fn)
    .finally(() => el.classList.remove('is-refreshing'));
}

function keepViewportStable(anchorEl, fn) {
  // Capture the element’s distance from the viewport top before we mutate the DOM
  const before = anchorEl ? anchorEl.getBoundingClientRect().top : null;

  return Promise.resolve(fn()).finally(() => {
    if (before == null || !anchorEl) return;
    const after = anchorEl.getBoundingClientRect().top;
    const delta = after - before;
    // Counter-scroll by the same delta so the element (and the user's viewport) doesn’t “jump”
    if (Math.abs(delta) > 1) {
      window.scrollBy({ top: delta, left: 0, behavior: 'auto' });
    }
  });
}

function replaceChildrenFast(el, newChildrenFragment) {
  while (el.firstChild) el.removeChild(el.firstChild);
  el.appendChild(newChildrenFragment);
}

async function renderExploreRowNoBlink(rowEl, rowId, count = 10) {
  if (!rowEl) return;

  // Ensure we have a buffer of items
  const st0 = exploreState.get(rowId) || {};
  await ensureExploreBuffer(rowId, st0.genre || '', count);

  const st = exploreState.get(rowId);
  if (!st || !Array.isArray(st.items) || st.items.length === 0) return;

  // 🔒 Freeze current height & scroll to avoid “jump”
  const prevMinHeight = rowEl.style.minHeight;
  const prevScrollLeft = rowEl.scrollLeft;
  const frozenHeight = rowEl.offsetHeight;            // current visual height
  rowEl.style.minHeight = frozenHeight + 'px';        // keep layout stable

  // Build off-screen
  const off = document.createElement('div');
  off.style.cssText = 'position:absolute; left:-9999px; top:-9999px; visibility:hidden;';
  document.body.appendChild(off);

  // Build cards off-DOM
  const limit = Math.min(count, st.items.length);
  for (let i = 0; i < limit; i++) {
    off.appendChild(createCard(st.items[i], true, wishlistRequestedTitles));
  }

  // Wait for key images (short cap)
  await waitForImagesToLoad(off, { timeoutMs: 900 });

  // Move children into a fragment and swap atomically
  const frag = document.createDocumentFragment();
  while (off.firstChild) frag.appendChild(off.firstChild);

  // Prevent browser from trying to auto-scroll during DOM ops
  const prevScrollBehavior = rowEl.style.scrollBehavior;
  rowEl.style.scrollBehavior = 'auto';

  replaceChildrenFast(rowEl, frag);

  // Restore scroll position and clean up freezes
  rowEl.scrollLeft = prevScrollLeft;
  rowEl.style.scrollBehavior = prevScrollBehavior || '';
  rowEl.style.minHeight = prevMinHeight || '';

  // Update state so appendExploreItems() continues from here
  st.loaded = limit;

  document.body.removeChild(off);
}

let _titleGenres = new Map();
let _myGenresCurrent = null;

// Build a genre index: name -> [items]
function _buildLocalGenreIndex() {
  const idx = new Map();
  const libItems = [...(window.library?.movies||[]), ...(window.library?.tv||[])];
  libItems.forEach(item => {
    const key = _norm(item.title);
    const meta = _titleGenres.get(key);
    const genres = (meta?.genres)||[];
    genres.forEach(g => {
      const arr = idx.get(g.name) || [];
      arr.push(item);
      idx.set(g.name, arr);
    });
  });
  return idx;
}

function _slug(s='') {
  return String(s).toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
}

// Render rows for each genre we actually have
function renderMyGenres() {
  const wrap = document.getElementById('myGenresWrap');
  if (!wrap) return;

  wrap.innerHTML = '';

  const idx = _buildLocalGenreIndex();
  if (idx.size === 0) {
    wrap.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No genres detected yet.</p>';
    return;
  }

  // Sort by count desc
  const entries = Array.from(idx.entries()).sort((a,b) => b[1].length - a[1].length);

  entries.forEach(([genreName]) => {
    const gid = _slug(genreName);

    // Build block with an empty row (we'll populate immediately)
    const section = document.createElement('div');
    section.className = 'my-genre-block';
    section.innerHTML = `
      <h3 class="subsection-title">${genreName}</h3>
      <div class="scroll-container" id="myGenreRow_${gid}"></div>
    `;
    wrap.appendChild(section);

    // Attach an inline title action as REFRESH (no Show state)
    const btn = addSidebarRefresh(
      `myGenreRow_${gid}`,
      async () => { await myGenresRefresh(genreName); },
      'Refresh',
      `Refresh myGenreRow_${gid}`
    );
    if (btn) setSidebarBtnState(btn, 'refresh', 'Refresh', `myGenreRow_${gid}`);

    // Populate the row immediately (like Explore does)
    _renderMyGenreRow(genreName).catch(e => console.warn('render genre failed:', genreName, e));
  });

  // Optional: auto-show the biggest genre first
  // const first = entries[0]?.[0];
  // if (first) myGenresShowOnly(first);
}

async function myGenresShowOnly(genreName) {
  const idx = _buildLocalGenreIndex();
  const selRowId = `myGenreRow_${_slug(genreName)}`;
  const selRow   = document.getElementById(selRowId);
  const sec      = selRow?.closest('.my-genre-block');

  await keepViewportStable(sec, async () => {
    // 1) Clear all other rows (titles/headers remain), set all buttons → "Show"
    Array.from(idx.keys()).forEach(name => {
      const otherRowId = `myGenreRow_${_slug(name)}`;
      const otherRow   = document.getElementById(otherRowId);
      if (otherRow) otherRow.innerHTML = '';
      const btn = otherRow?._sidebarBtn;
      if (btn) {
        setSidebarBtnState(btn, 'show', 'Show', otherRowId);
        btn._dynamicHandler = async () => { await myGenresShowOnly(name); };
      }
    });

    // 2) Render the selected row
    await _renderMyGenreRow(genreName);

    // 3) Switch the selected row’s button → "Refresh"
    const selBtn = selRow?._sidebarBtn ?? null;
    if (selBtn) {
      setSidebarBtnState(selBtn, 'refresh', 'Refresh', selRowId);
      selBtn._dynamicHandler = async () => { await myGenresRefresh(genreName); };
    }

    _myGenresCurrent = genreName;
  });
}

// REFRESH behavior: re-render the currently shown genre
async function myGenresRefresh(genreName) {
  await _renderMyGenreRow(genreName);
}

async function _renderMyGenreRow(genreName) {
  const rowId = `myGenreRow_${_slug(genreName)}`;
  const rowEl = document.getElementById(rowId);
  if (!rowEl) return;

  const idx = _buildLocalGenreIndex();
  const items = idx.get(genreName) || [];

  // Freeze current height
  const prevMinHeight = rowEl.style.minHeight;
  rowEl.style.minHeight = rowEl.offsetHeight + 'px';

  await withSeamlessOverlay(rowEl, async () => {
    const frag = document.createDocumentFragment();
    if (!items.length) {
      const p = document.createElement('p');
      p.style.cssText = 'color:#aaa; font-size:24px; text-align:center; width:100%;';
      p.textContent = 'No titles in this genre.';
      frag.appendChild(p);
    } else {
      const shuffled = items.slice();
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      shuffled.forEach(it => frag.appendChild(createCard(it)));
    }
    replaceChildrenFast(rowEl, frag);
  });

  // Release freeze
  rowEl.style.minHeight = prevMinHeight || '';
}

// Ask server for all genres for our library and fill _titleGenres
function annotateLibraryWithGenres() {
  return new Promise(resolve => {
    const lib = window.library || {movies:[], tv:[]};
    google.script.run
      .withSuccessHandler(map => {
        _titleGenres = new Map();
        Object.keys(map || {}).forEach(k => {
          _titleGenres.set(_norm(k), map[k]);  // ✅ store by normalized title
        });
        resolve();
      })
      .withFailureHandler(() => resolve())
      .getGenresForLibrary(lib);
  });
}

// Create card
function createCard(item, isTMDb = false, wishlistTitles = []) {
  const displayTitle = item.title || item.name || "No Title";
  const card = document.createElement("div");
  card.classList.add("movie-card");
  card.innerHTML = "";

  // Poster
  const img = document.createElement("img");
  img.src = item.poster;
  img.alt = displayTitle;
  img.loading = "lazy";
  card.appendChild(img);

  // Title
  const titleDiv = document.createElement("div");
  titleDiv.classList.add("movie-title");
  titleDiv.textContent = displayTitle;
  card.appendChild(titleDiv);

  // ▼ Genres: tag local (Drive) cards for filtering/styling later
  if (!isTMDb && item && item.title) {
    try {
      const meta = _titleGenres.get(_norm(item.title));
      const names = (meta?.genres || []).map(g => g.name).filter(Boolean);
      if (names.length) {
        // e.g. data-genres="Action|Drama"
        card.dataset.genres = names.join('|');
      }
    } catch (e) {
      console.warn('genre tag failed for', item?.title, e);
    }
  }

  // Wishlist button for TMDb items
  if (isTMDb) {
    // Store TMDb genre IDs for filtering
    const gids = Array.isArray(item.genre_ids) ? item.genre_ids : [];
    const btn = document.createElement("button");
    btn.classList.add("add-btn");

    const alreadyRequested = (wishlistTitles || []).some(w =>
      String(w.title || "").toLowerCase().trim() === displayTitle.toLowerCase().trim() &&
      w.status === "Wishlist"
    );

    if (alreadyRequested) {
      btn.textContent = "✔";
      btn.title = "Requested";
      btn.disabled = true;
      btn.style.backgroundColor = "green";
    } else {
      btn.textContent = "+";
      btn.title = "Add to Wishlist";
      btn.style.backgroundColor = "#e50914";
      btn.addEventListener("click", e => {
        e.stopPropagation();
        addToWishlist(displayTitle, item.poster, btn);
      });
    }
    card.appendChild(btn);
  }

  card.addEventListener("click", async () => {
    if (isTMDb) {
      // Route TMDb clicks through the centralized preview (auto-sets button)
      const guessYear =
        (item.release_date && item.release_date.split?.("-")?.[0]) ||
        (item.first_air_date && item.first_air_date.split?.("-")?.[0]) || "";

      showTMDbPreviewByTitle(displayTitle, guessYear);

      // Episodes panel logic stays the same: only open if we truly have local episodes
      const local = findLocalByTitle(displayTitle);
      if (local?.episodes?.length) {
        showEpisodesList(local);
      } else {
        const epSec = document.getElementById("episodesSection");
        const epGrid = document.getElementById("episodesGrid");
        if (epSec) epSec.style.display = "none";
        if (epGrid) epGrid.innerHTML = "";
      }
    } else {
      // Local items: In Available/Recently, fill the TMDb preview only (no episodes list)
      const inAvailable = card.closest('#availableToWatchSection');
      const inRecently  = card.closest('#recentlyAddedSection');

      if (inAvailable || inRecently) {
        // Centralized function will auto-detect local and set “Watch Now”
        showTMDbPreviewByTitle(displayTitle, item.year || "");
        // do NOT open episodes list here
      } else {
        // Other lists keep the original behavior
        showEpisodesList(item);
      }
    }
  });

  return card;
}

function openEpisodeInNewTab(url, showTitle, episodeTitle = "") {
  // 🔹 instant local UI: add/update CW immediately
  if (currentProfile && showTitle) {
    upsertContinueWatchingCard(showTitle, episodeTitle);

    // persist to server (fire-and-forget)
    google.script.run
      .withFailureHandler(err => console.warn("saveProfileProgress failed:", err))
      .saveProfileProgress(currentProfile, showTitle, episodeTitle);
  }

  // also keep Available row feeling fresh
  try { updateAvailableToWatchRow(); } catch(_) {}

  // open in a new tab (popup-safe)
  try {
    window.open(url, "_blank", "noopener");
  } catch (e) {
    location.href = url;
  }
}

function showEpisodesList(showLike) {
  // Ensure episodesSection exists
  let section = document.getElementById("episodesSection");
  if (!section) {
    section = document.createElement("div");
    section.id = "episodesSection";
    section.style.display = "none";
    section.innerHTML = `
      <h2 class="subsection-title" id="episodesTitle"></h2>
      <div class="scroll-container" id="episodesGrid"></div>
    `;
    const cwSection = document.getElementById("continueWatchingSection");
    if (cwSection) cwSection.insertAdjacentElement("beforebegin", section);
    else document.body.appendChild(section);
  }

  const titleEl = document.getElementById("episodesTitle");
  const grid = document.getElementById("episodesGrid");
  if (!grid) return;

  // Hide TMDb preview for local items
  const preview = document.getElementById("tmdbDetailsPreview");
  if (preview) preview.style.display = "none";

  // Clear + show section
  grid.innerHTML = "";
  section.style.display = "block";

  const displayTitle = showLike.title || showLike.name || "Episodes";
  let eps = Array.isArray(showLike.episodes) ? [...showLike.episodes] : [];

  // If no episodes on the object, fetch them from the server by title.
  if (!eps.length && (showLike.title || showLike.name)) {
    const wantTitle = showLike.title || showLike.name;

    // Temporarily show a loading state in the grid
    const gridEl = document.getElementById("episodesGrid");
    if (gridEl) gridEl.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">Loading episodes…</p>';

    google.script.run
      .withSuccessHandler(payload => {
        const fromServer = Array.isArray(payload?.episodes) ? payload.episodes : [];
        if (!fromServer.length && payload?.url) {
          fromServer.push({ title: "Play", url: payload.url, poster: payload.poster || showLike.poster });
        }
        showEpisodesList({
          title: payload.title || wantTitle,
          poster: payload.poster || showLike.poster,
          episodes: fromServer
        });
      })
      .withFailureHandler(() => {
        if (gridEl) gridEl.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">No episodes found.</p>';
      })
      .getEpisodesByTitle(wantTitle);
    return; // stop here; the success handler will re-render
  }

  // If no episodes but we have a direct URL, create a single "Play" card
  if ((!eps || eps.length === 0) && showLike.url) {
    eps = [{ title: "Play", url: showLike.url }];
  }

  // ✅ Sort episodes alphabetically by title (case-insensitive)
  eps.sort((a, b) => {
    return (a.title || "").toLowerCase().localeCompare((b.title || "").toLowerCase());
  });

  const label = (eps.length > 1) ? "Episodes" : "Collection";
  titleEl.innerHTML = `${displayTitle} — <span style="opacity:.8">${label}</span>`;

  // Close button
  let closeBtn = titleEl.querySelector("button.episodes-close");
  if (!closeBtn) {
    closeBtn = document.createElement("button");
    closeBtn.className = "episodes-close";
    closeBtn.type = "button";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => {
      section.style.display = "none";
      grid.innerHTML = "";
    });
    titleEl.appendChild(closeBtn);
  }

  // Build cards
  if (!eps || eps.length === 0) {
    grid.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">No episodes found.</p>';
  } else {
    const last = getLastWatchedEpisodeFor(displayTitle);
    eps.forEach(ep => {
      const card = document.createElement("div");
      card.className = "movie-card";
      if (_norm(ep.title) === _norm(last)) card.classList.add("last-watched");
      card.innerHTML = `
        <img src="${ep.poster || showLike.poster}" alt="${ep.title}" loading="lazy">
        <div class="movie-title">${ep.title}</div>
      `;
        card.addEventListener("click", () => {
        // Visually select + mark as last watched immediately
        grid.querySelectorAll(".movie-card").forEach(c => 
          c.classList.remove("active-episode", "last-watched")
        );
        card.classList.add("active-episode", "last-watched");

        // Update in-memory + localStorage so UI updates without refresh
        saveLastWatchedEpisodeFor(displayTitle, ep.title);

        // 🔁 Refresh the "Available to Watch" row live
        updateAvailableToWatchRow();

        // Persist to sheet (your existing behavior) + open
        openEpisodeInNewTab(ep.url, displayTitle, ep.title);
      });
      grid.appendChild(card);
    });
  }

  // Auto-scroll to last watched (double RAF to ensure layout on mobile)
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      const lastWatchedCard = grid.querySelector(".last-watched");
      if (lastWatchedCard) {
        lastWatchedCard.classList.add("active-episode"); // optional
        scrollCardIntoViewHorizontally(grid, lastWatchedCard, { smooth: true });
      }
    });
  });

  // Smooth scroll the section into view (account for sticky header)
  setTimeout(() => {
    const yOffset = -80; // adjust for sticky header height
    const y = section.getBoundingClientRect().top + window.scrollY + yOffset;
    window.scrollTo({ top: y, behavior: 'smooth' });
  }, 50);
}

// (Optional but harmless): ensure global
window.showEpisodesList = showEpisodesList;

// --- Available-to-Watch (batched) ---
const availableState = {
  initialized: false,
  loading: false,
  loaded: 0,
  items: [],
};

function buildAvailableList() {
  if (!window.library) return [];
  const { movies = [], tv = [] } = window.library;
  // Shuffle a fresh combined list
  return shuffleArray([...movies, ...tv]);
}

function appendAvailableItems(limit = 5) {
  const grid = document.getElementById("availableToWatchGrid");
  if (!grid || !availableState.items.length) return;

  const start = availableState.loaded;
  const end = Math.min(start + limit, availableState.items.length);
  for (let i = start; i < end; i++) {
    grid.appendChild(createCard(availableState.items[i]));
  }
  availableState.loaded = end;
}

function initAvailableToWatch({ allowSkeletons = true } = {}) {
  const grid = document.getElementById("availableToWatchGrid");
  if (!grid) return;

  // Rebuild fresh shuffled list
  availableState.initialized = false;
  availableState.loading = false;
  availableState.loaded = 0;
  availableState.items = buildAvailableList();

  // If nothing at all, show empty state and bail
  if (!availableState.items || availableState.items.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center; width:100%;">No videos available.</p>';
    return;
  }

  const alreadyHasCards = !!grid.querySelector(".movie-card");

  // Only show skeletons when it's the *very first* paint (no cards yet)
  if (allowSkeletons && !alreadyHasCards) {
    grid.innerHTML = `
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    `;
  }

  // Build off-DOM and swap in atomically (no flicker either way)
  requestAnimationFrame(() => {
    const frag = document.createDocumentFragment();
    const limit = 10;
    availableState.items.slice(0, limit).forEach(it => frag.appendChild(createCard(it)));
    replaceChildrenFast(grid, frag);
    availableState.loaded = Math.min(limit, availableState.items.length);
    availableState.initialized = true;
  });
}

// Load Library via google.script.run and sync wishlist statuses automatically
function loadLibrary({ force = false, showSkeletons = true } = {}) {
  // skip if already loaded and not forcing
  if (libraryLoaded && !force) return Promise.resolve();

  const grid = document.getElementById("availableToWatchGrid");

  if (showSkeletons && grid) {
    grid.innerHTML = `
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    `;
  }

  return new Promise(resolve => {
    google.script.run
      .withSuccessHandler(data => {
        fullLibrary = (data.movies || []).concat(data.tv || []);
        window.library = data;
        libraryLoaded = true;

        try {
          initAvailableToWatch({ allowSkeletons: showSkeletons });
        } catch (err) {
          console.error("❌ Error in initAvailableToWatch:", err);
          showPopup("Error rendering Available to Watch.");
        }

        // 🔽 New: annotate local library with genres,
        // but only render the lists after the user clicks “Show My Genres”
        try {
          annotateLibraryWithGenres()
          .then(() => {
            try { renderMyGenres(); } 
            catch (e) { console.warn("renderMyGenres failed:", e); }
          })
          .catch(e => console.warn("annotateLibraryWithGenres failed:", e));
        } catch (e) {
          console.warn("annotateLibraryWithGenres scheduling failed:", e);
        }

        resolve();
      })
      .withFailureHandler(err => {
        console.error("❌ Failed to load library:", err);
        if (showSkeletons && grid) {
          grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">Error loading library.</p>';
        }
        resolve();
      })
      .getLibraryAndSyncWishlist();
  });
}

function buildCardsFragment(items, limit = 10) {
  const frag = document.createDocumentFragment();
  const slice = items.slice(0, limit);
  slice.forEach((item, idx) => {
    const card = createCard(item);
    // Nudge first few posters to load sooner for snappier visual completion
    const img = card.querySelector('img');
    if (img) {
      img.decoding = 'async';
      if (idx < 4) img.loading = 'eager';
      if (idx < 2) img.fetchPriority = 'high'; // 👈 new
    }
    frag.appendChild(card);
  });
  return frag;
}

function prewarmAvailableSample(limit = 10) {
  // Fire & forget: warms a ready-to-render set for the next refresh
  callScript('getRandomLibrarySample', limit).then(sample => {
    _nextAvailableSample = Array.isArray(sample) && sample.length ? sample : null;
  }).catch(() => { _nextAvailableSample = null; });
}

async function refreshAvailableToWatch({ limit = 10 } = {}) {
  const grid = document.getElementById('availableToWatchGrid');
  if (!grid) return;

  await withSeamlessOverlay(grid, async () => {
    // 1) Use a prewarmed set immediately if we have it
    let sample = _nextAvailableSample;
    _nextAvailableSample = null; // consume it

    // 2) If no prewarm available, fetch one now
    if (!sample) {
      sample = await callScript('getRandomLibrarySample', limit);
    }

    // 3) If we got a server-sampled set, render that
    if (Array.isArray(sample) && sample.length) {
      const frag = buildCardsFragment(sample, limit);
      replaceChildrenFast(grid, frag);

      // keep overlay until first few images actually paint (like Explore feel)
      await waitForImagesToLoad(grid, { timeoutMs: 900 });

      // update state
      availableState.items = sample.slice();
      availableState.loaded = Math.min(limit, sample.length);
      availableState.initialized = true;
      availableState.loading = false;

      // 4) Prewarm the *next* batch in the background
      prewarmAvailableSample(limit);
      return;
    }

    // 5) Fallback to local library (no Drive roundtrip)
    if (!window.library) {
      await loadLibrary({ force: false, showSkeletons: false });
    }
    const newItems = buildAvailableList();

    if (!Array.isArray(newItems) || newItems.length === 0) {
      grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center; width:100%;">No videos available.</p>';
      availableState.items = [];
      availableState.loaded = 0;
      return;
    }

    const frag = buildCardsFragment(newItems, limit);
    replaceChildrenFast(grid, frag);

    // Hold overlay just long enough for posters to pop in
    await waitForImagesToLoad(grid, { timeoutMs: 900 });

    availableState.items = newItems.slice();
    availableState.loaded = Math.min(limit, newItems.length);
    availableState.initialized = true;
    availableState.loading = false;

    // Still prewarm for the *next* click
    prewarmAvailableSample(limit);
  });
}

/**
 * Prewarm a future set for an Explore row so refresh can be instant.
 * @param {string} rowId   - e.g. 'tmdbExploreAllRow'
 * @param {string} genreId - TMDb genre id ('' means "All")
 * @param {number} count   - how many items to prefetch
 */
function prewarmExploreRow(rowId, genreId = '', count = 16) {
  // Fire & forget
  fetchMixedTopRated(genreId, count)
    .then(items => {
      if (Array.isArray(items) && items.length) {
        _exploreNextSample.set(rowId, items.slice(0, count));
      } else {
        _exploreNextSample.delete(rowId);
      }
    })
    .catch(() => _exploreNextSample.delete(rowId));
}

// Live refresh helper for the Available row
function updateAvailableToWatchRow() {
  // quick reshuffle/rebuild without a Drive call
  try { refreshAvailableToWatch(); } catch (e) { console.warn(e); }
}

let currentProfile = null;

const loadingScreen = document.getElementById("loadingScreen");
let _hideLoaderTimer = null;
function hideLoadingScreen(delay = 300) {
  if (_hideLoaderTimer) {
    clearTimeout(_hideLoaderTimer);
    _hideLoaderTimer = null;
  }
  _hideLoaderTimer = setTimeout(() => {
    loadingScreen.style.display = "none";
    _hideLoaderTimer = null;
  }, delay);
}

window.addEventListener("load", () => {
  const app = document.getElementById("appContent");
  const profileModal = document.getElementById("profileModal");

  // Show the app under the loader
  app.style.display = "block";
  loadingScreen.style.display = "flex"; // loader visible during preloads

  // Preload Library + Recently Added while the loader is up
  Promise.all([ loadLibrary(), loadRecentlyAdded() ])
    .then(() => waitForImagesToLoad(app, { timeoutMs: 2500 }))
    .finally(() => {
      // Preloads done → show profile picker and drop the loader
      profileModal.classList.add("active");
      hideLoadingScreen(0);
    });

  // Manual profile selection
  document.querySelectorAll(".profile-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const chosenName = btn.dataset.profile;
      const imgEl = btn.querySelector("img");
      const chosenIcon = imgEl ? imgEl.src : "https://via.placeholder.com/50";
      selectProfile(chosenName, chosenIcon);
    });
  });

  // 🔎 Quick server ping to verify Apps Script calls + TMDb key status
  try {
    google.script.run
      .withSuccessHandler(res => {
        console.log('TMDb key test:', res);
      })
      .withFailureHandler(err => {
        console.error('TMDb key test failed:', err);
      })
      .testTmdbKey();
  } catch (e) {
    console.error('google.script.run not available (not in HtmlService context?):', e);
  }

  const switchBtn = document.getElementById("switchProfileBtn");
  if (switchBtn) {
    const openPicker = () => {
      const profileModal = document.getElementById("profileModal");
      const app = document.getElementById("appContent");
      if (profileModal) profileModal.classList.add("active"); // show picker
      if (app) app.style.display = "block";                   // keep app visible
      // no clearing of localStorage or UI
    };
    switchBtn.addEventListener("click", openPicker);
    switchBtn.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") { e.preventDefault(); openPicker(); }
    });
  }

  // My Genres are always visible; reveal + render immediately (part of Available)
  revealMyGenres();

  // == Attach sidebar refresh buttons for all visible lists
  attachAllListSidebars();

  // ✨ Build the Explore “All” row immediately on load
  ensureExploreBuiltOnce();

  // 🔥 Prewarm the first Available-to-Watch batch for instant refresh
  prewarmAvailableSample(10);
});

// ✅ Start with everything visible
(function showExploreAtStart() {
  try { showAllSections(); } catch (_) {}
})();

document.getElementById("searchInput").addEventListener("input", function (e) {
  const query = (e.target.value || "").toLowerCase().trim();
  const searchResults = document.getElementById("searchResultsSection");
  const searchGrid = document.getElementById("searchResultsGrid");

  // Everything we hide/show during search
  const sectionsToToggle = [
    "continueWatchingSection",
    "recentlyAddedSection",
    "availableToWatchSection",
    "wishlistSection",
    "tmdbDetailsPreview",
    "episodesSection",
    "tmdbExploreAllSection",
    "tmdbExploreComedySection",
    "tmdbExploreWesternSection",
    "tmdbExploreActionSection",
    "tmdbExploreDramaSection",
    "tmdbExploreAnimationSection",
    "tmdbExploreHistorySection",
    "tmdbExploreScifiSection"
  ];

  // If the library isn't ready, bail
  if (!Array.isArray(fullLibrary) || fullLibrary.length === 0) return;

  if (query === "") {
    // Always restore these
    ["recentlyAddedSection","availableToWatchSection",
    "tmdbDetailsPreview","episodesSection","tmdbExploreAllSection"]
      .forEach(id => { const el = document.getElementById(id); if (el) el.style.display = "block"; });

    // Always show per-genre sections (genres are permanently revealed)
    [
      "tmdbExploreComedySection","tmdbExploreWesternSection","tmdbExploreActionSection",
      "tmdbExploreDramaSection","tmdbExploreAnimationSection","tmdbExploreHistorySection",
      "tmdbExploreScifiSection"
    ].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = "block";
    });

    // Show the Explore header
    const tmdbHeader = document.querySelector(".tmdb-title");
    if (tmdbHeader) tmdbHeader.style.display = "block";

    // Hide search results
    if (searchResults) searchResults.style.display = "none";
    if (searchGrid) searchGrid.innerHTML = "";
    return;
  }

  // Hide all non-search sections
  sectionsToToggle.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
  // Hide the Explore header (h2.tmdb-title)
  const tmdbHeader = document.querySelector(".tmdb-title");
  if (tmdbHeader) tmdbHeader.style.display = "none";

  // Show and populate search results
  if (searchResults) searchResults.style.display = "block";
  if (searchGrid) {
    searchGrid.innerHTML = "";
    const filtered = fullLibrary.filter(item =>
      (item.title || "").toLowerCase().includes(query)
    );
    if (filtered.length) {
      filtered.forEach(item => searchGrid.appendChild(createCard(item)));
    } else {
      searchGrid.innerHTML = '<p style="text-align:center;color:#aaa;font-size:24px;">No results found.</p>';
    }
  }
});

// Live sync CW across tabs/windows via localStorage events
window.addEventListener("storage", (e) => {
  if (!e || !e.key || !currentProfile) return;
  const wantKey = `cwSync:${currentProfile}`;
  if (e.key !== wantKey) return;

  try {
    const msg = JSON.parse(e.newValue || "{}");
    if (!msg || !msg.action || !msg.title) return;

    if (msg.action === "upsert") {
      upsertContinueWatchingCard(msg.title, msg.episode || "");
    } else if (msg.action === "remove") {
      const grid = document.getElementById("continueWatchingGrid");
      if (!grid) return;
      const key = (s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase())(msg.title);
      const card = Array.from(grid.children).find(el => el.dataset?.titleNorm === key);
      if (card) card.remove();
      if (grid.children.length === 0) {
        grid.innerHTML = "<p>No titles to continue watching yet.</p>";
      }
    }
  } catch(_) {}
});

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const _norm = s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();
function findLocalByTitle(title) {
  if (!title || !window.library) return null;
  const { movies = [], tv = [] } = window.library;
  return [...movies, ...tv].find(x => _norm(x.title) === _norm(title)) || null;
}

// Cache of "last watched" by normalized title for current profile
let cwProgressByTitle = new Map();

function setCWCache(items = []) {
  cwProgressByTitle.clear();
  items.forEach(it => {
    if (it && it.title) {
      cwProgressByTitle.set(_norm(it.title), String(it.episode || ""));
    }
  });
}

function getLastWatchedEpisodeFor(title) {
  const k = _norm(title);
  if (cwProgressByTitle.has(k)) return cwProgressByTitle.get(k) || "";
  try {
    return localStorage.getItem(`lastWatched_${k}`) || "";
  } catch (_) {
    return "";
  }
}

function saveLastWatchedEpisodeFor(showTitle, episodeTitle) {
  try {
    const key = `lastWatched_${_norm(showTitle)}`;
    localStorage.setItem(key, episodeTitle);
  } catch (err) {
    console.error("Could not save last watched:", err);
  }
}

// Horizontal scroll centering helper (mobile + desktop safe)
function scrollCardIntoViewHorizontally(container, card, { smooth = true } = {}) {
  if (!container || !card) return;
  const cardCenter = card.offsetLeft + card.offsetWidth / 2;
  const target = Math.max(0, cardCenter - container.clientWidth / 2);
  container.scrollTo({ left: target, top: 0, behavior: smooth ? 'smooth' : 'auto' });
}

// Smooth vertical scroll helper (accounts for sticky headers)
function scrollSectionIntoView(el, { offset = -80, behavior = 'smooth' } = {}) {
  if (!el) return;
  const y = el.getBoundingClientRect().top + window.scrollY + offset;
  window.scrollTo({ top: y, behavior });
}

// WISHLIST
// === helpers (lightweight) ===
const _normTitle = s => String(s || '').replace(/\u00A0/g, ' ').trim().toLowerCase();

function upsertWishlistCard({ title, poster }) {
  const grid = document.getElementById('wishlistGrid');
  if (!grid || !title) return null;

  // Clear placeholder if present
  if (!grid.querySelector('.movie-card') && grid.textContent.includes('No requested items')) {
    grid.innerHTML = '';
  }

  // Avoid duplicates
  const exists = Array.from(grid.children).some(el => {
    const t = el.querySelector('.movie-title')?.textContent || '';
    return _normTitle(t) === _normTitle(title);
  });
  if (exists) return null;

  // Build card at top
  const card = document.createElement('div');
  card.className = 'movie-card';
  card.innerHTML = `
    <img src="${poster || ''}" alt="${title}" loading="lazy" onerror="this.style.display='none'">
    <div class="movie-title">${title}</div>
  `;
  grid.insertBefore(card, grid.firstChild);

  // Ensure section visible ONLY when Explore group is active
  const section = document.getElementById('wishlistSection');
  if (section && _activeGroup === 'explore') section.style.display = 'block';

  return card;
}

function broadcastWishlist(action, payload) {
  try {
    localStorage.setItem('wishlistSync', JSON.stringify({ t: Date.now(), action, payload }));
  } catch (_) {}
}

function _wishlistCacheUpsert({ title, poster }) {
  // keep your in-memory caches aligned so + buttons disable correctly
  try {
    const norm = s => String(s || '').trim().toLowerCase();
    if (!Array.isArray(wishlistRequestedTitles)) wishlistRequestedTitles = [];
    const has = wishlistRequestedTitles.some(x => norm(x.title) === norm(title));
    if (!has) wishlistRequestedTitles.push({ title, poster, status: 'Wishlist' });

    // force ensureWishlistAll() to re-fetch later if needed
    _wishlistAllCachePromise = null;
  } catch (_) {}
}

function addToWishlist(title, poster, btn) {
  // Optimistic UI on TMDb "+" button
  if (btn) {
    btn.textContent = "✔";
    btn.style.backgroundColor = "green";
    btn.disabled = true;
  }

  // Optimistic: show in Wishlist immediately + update caches + broadcast
  const optimisticCard = upsertWishlistCard({ title, poster });
  _wishlistCacheUpsert({ title, poster });
  broadcastWishlist('add', { title, poster });

  // Persist to server
  google.script.run
    .withSuccessHandler(() => {
      // ✅ Success: do nothing (no popup). Button state + card are already updated.
    })
    .withFailureHandler(err => {
      // Roll back button
      if (btn) {
        btn.textContent = "+";
        btn.style.backgroundColor = "#e50914";
        btn.disabled = false;
      }
      // Roll back optimistic card
      if (optimisticCard && optimisticCard.parentNode) optimisticCard.parentNode.removeChild(optimisticCard);
      // Roll back caches
      try {
        const k = (s => String(s || '').replace(/\u00A0/g, ' ').trim().toLowerCase())(title);
        wishlistRequestedTitles = (wishlistRequestedTitles || []).filter(x => (String(x.title).trim().toLowerCase()) !== k);
      } catch(_) {}
      // ❌ Keep error popup (so users know it failed)
      showPopup(`❌ Failed to add <b>${title}</b>.<br>${err?.message || 'Please try again.'}`);
    })
    .addToWishlistSheet(title, poster);
}

// === Cross-tab live sync for Wishlist ===
window.addEventListener('storage', (e) => {
  if (!e || e.key !== 'wishlistSync' || !e.newValue) return;
  try {
    const msg = JSON.parse(e.newValue);
    if (msg?.action === 'add' && msg.payload?.title) {
      upsertWishlistCard({ title: msg.payload.title, poster: msg.payload.poster || '' });
      _wishlistCacheUpsert({ title: msg.payload.title, poster: msg.payload.poster || '' });
    }
    // If you later add “remove from wishlist”, handle msg.action === 'remove' here.
  } catch (_) {}
});

function renderWishlist(items) {
  const grid = document.getElementById('wishlistGrid');
  grid.innerHTML = '';

  // Normalize shapes/keys coming from server: {title, poster} OR {Title, Poster} etc.
  const normalized = (Array.isArray(items) ? items : []).map(it => {
    const title = (it && (it.title || it.Title || it.name || it.Name)) || 'Untitled';
    const poster = (it && (it.poster || it.Poster || it.image || it.Image)) || '';
    return { title: String(title).trim(), poster: String(poster).trim() };
  }).filter(it => it.title); // keep only valid titles

  if (normalized.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No requested items found.</p>';
    return;
  }

  shuffleArray(normalized).forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" onerror="this.style.display='none'">
      <div class="movie-title">${item.title}</div>
    `;
    grid.appendChild(card);
  });

  // Only show if Explore group is currently active
  const section = document.getElementById('wishlistSection');
  if (section && _activeGroup === 'explore') section.style.display = 'block';
}
function loadWishlist() {
  return new Promise(resolve => {
    // Fetch wishlist from the server
    google.script.run
      .withSuccessHandler(items => {
        renderWishlist(items || []);
        resolve();
      })
      .withFailureHandler(err => {
        console.error('getRequestedWishlist failed:', err);
        renderWishlist([]);
        resolve();
      })
      .getRequestedWishlist();
  });
}

// RECENTLY ADDED
function renderRecentlyAdded(items) {
  const grid = document.getElementById('recentlyAddedGrid');
  grid.innerHTML = '';
  if (!items || items.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No recent videos found.</p>';
    return;
  }

  // Items are already sorted newest → oldest by the server
  items.forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" decoding="async">
      <div class="movie-title">${item.title}</div>
    `;
    card.addEventListener('click', () => {
      // Populate TMDb details preview (trailer + overview) only
      showTMDbPreviewByTitle(item.title || item.name || "", item.year || "");
      // No episodes list for Recently Added
    });
    grid.appendChild(card);
  });
}

function buildRecentlyAddedFragment(items) {
  const frag = document.createDocumentFragment();
  if (!items || !items.length) {
    const p = document.createElement('p');
    p.style.cssText = 'color:#aaa; font-size:24px; text-align:center;';
    p.textContent = 'No recent videos found.';
    frag.appendChild(p);
    return frag;
  }
  items.forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" decoding="async">
      <div class="movie-title">${item.title}</div>
    `;
    card.addEventListener('click', () => {
      showTMDbPreviewByTitle(item.title || item.name || "", item.year || "");
    });
    frag.appendChild(card);
  });
  return frag;
}

function loadRecentlyAdded() {
  const grid = document.getElementById('recentlyAddedGrid');
  grid.innerHTML = `
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
  `;

  return new Promise(resolve => {
    google.script.run.withSuccessHandler(items => {
      // ✅ cache newest→oldest for instant reshuffles later
      _recentlyCache.items = Array.isArray(items) ? items : [];
      _recentlyCache.stamp = Date.now();

      renderRecentlyAdded(items);
      resolve();
    }).withFailureHandler(err => {
      console.error("❌ Failed to load recently added:", err);
      showPopup("Error loading recently added.");
      resolve();
    }).getRecentVideos(14);
  });
}

function _exploreSetState(rowId, genre, items) {
  // Reset row state with provided items so appendExploreItems() can render from cache
  const st = { genre, items: Array.isArray(items) ? items : [], loaded: 0, loading: false };
  exploreState.set(rowId, st);
  return st;
}

function _exploreRenderFirstBatch(rowEl, rowId, count = 10) {
  const frag = document.createDocumentFragment();
  appendExploreItems(frag, rowId, count);
  replaceChildrenFast(rowEl, frag);
}

function _arraysDifferById(a = [], b = []) {
  if (a.length !== b.length) return true;
  for (let i = 0; i < a.length; i++) if (a[i]?.id !== b[i]?.id) return true;
  return false;
}

function refreshExploreRowSmooth(rowId, genreId) {
  const rowEl = document.getElementById(rowId);
  if (!rowEl) return Promise.resolve();

  return withSeamlessOverlay(rowEl, async () => {
    // 1) Use prewarmed set instantly if available
    let items = _exploreNextSample.get(rowId) || null;
    if (items && items.length) {
      _exploreNextSample.delete(rowId); // consume
    } else {
      // 2) No prewarm available → fetch now
      items = await fetchMixedTopRated(genreId || '', 16);
    }

    if (Array.isArray(items) && items.length) {
      _exploreCache.set(rowId, { genre: genreId || '', items: items.slice(), stamp: Date.now() });
      _exploreSetState(rowId, genreId || '', items);

      // ⤵️ build off-screen, wait images, then atomic swap
      await renderExploreRowNoBlink(rowEl, rowId, 10);

      prewarmExploreRow(rowId, genreId || '', 16);
    }
  });
}

// CONTINUE WATCHING
function loadContinueWatching() {
  if (!currentProfile) {
    console.log("⚠️ No currentProfile, skipping continue watching");
    return Promise.resolve();
  }

  const ensureLibrary = window.library ? Promise.resolve() : loadLibrary();

  return ensureLibrary.then(() =>
    new Promise(resolve => {
      google.script.run
        .withSuccessHandler(data => {
          renderContinueWatching(data || []);
          resolve();
        })
        .withFailureHandler(err => {
          console.error("❌ getContinueWatching failed:", err);
          resolve();
        })
        .getContinueWatching(currentProfile);
    })
  );
}

function renderContinueWatching(items) {
  // newest → oldest by updatedAt; if missing, they fall to the bottom
  items = (items || []).slice().sort((a, b) => {
    const ta = Date.parse(a.updatedAt || '') || 0;
    const tb = Date.parse(b.updatedAt || '') || 0;
    return tb - ta;
  });

  setCWCache(items || []);
  const container = document.getElementById("continueWatchingGrid");
  if (!container) return;
  container.innerHTML = "";

  if (!items || !Array.isArray(items) || items.length === 0) {
    container.innerHTML = "<p>No titles to continue watching yet.</p>";
    return;
  }

  const library = window.library;
  if (!library) return;

  const normalize = (str) => (str || "").replace(/\u00A0/g, " ").trim().toLowerCase();
  const normCW   = (s)   => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();

  items.forEach((item) => {
    const driveItem = [...(library.movies || []), ...(library.tv || [])].find(
      (lib) => normalize(lib.title) === normalize(item.title)
    );
    if (!driveItem) return;

    const card = document.createElement("div");
    card.className = "movie-card";
    card.style.position = "relative";
    card.dataset.titleNorm = normCW(driveItem.title); // 👈 enable upsert/reorder

    card.innerHTML = `
      <img src="${driveItem.poster}" alt="${driveItem.title}" loading="lazy" decoding="async">
      <div class="movie-title">${driveItem.title}</div>
      <button class="cw-complete-btn"
              title="${item.episode ? `Remove \"${driveItem.title}\" — \"${item.episode}\" from Continue Watching` : `Remove \"${driveItem.title}\" from Continue Watching`}"
              aria-label="Remove ${driveItem.title} from Continue Watching">−</button>
    `;

    // Open episodes on card click (ignore minus button clicks)
    card.addEventListener("click", (e) => {
      if (e.target && typeof e.target.closest === "function" && e.target.closest(".cw-complete-btn")) return;
      showEpisodesList(driveItem);
    });

    // Minus button removes + broadcasts to other tabs
    const completeBtn = card.querySelector(".cw-complete-btn");
    if (completeBtn) {
      completeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const confirmMsg = item.episode
          ? `Mark "${driveItem.title}" — "${item.episode}" as complete?`
          : `Mark "${driveItem.title}" as complete?`;
        if (!window.confirm(confirmMsg)) return;

        // Optimistic: markComplete will remove this card locally
        markComplete(currentProfile, driveItem.title, card, item.episode || "");

        // 🔔 Broadcast the removal so other tabs update instantly
        try {
          localStorage.setItem(`cwSync:${currentProfile}`, JSON.stringify({
            t: Date.now(),
            action: "remove",
            title: driveItem.title
          }));
        } catch (_) {}
      });
    }

    container.appendChild(card);
  });

  const sec = document.getElementById("continueWatchingSection");
  if (sec) sec.style.display = "block";
}

// DETAILS & TRAILERS
async function fetchTMDbDetails(item, isTV = false) {
  return new Promise(resolve => {
    google.script.run
      .withSuccessHandler(data => {
        if (!data || data.error) {
          const trailerContainer = document.getElementById('tmdbTrailerContainer');
          const titleElem = document.getElementById('tmdbDetailsTitle');
          const dateElem = document.getElementById('tmdbDetailsReleaseDate');
          const overviewElem = document.getElementById('tmdbDetailsOverview');
          const preview = document.getElementById('tmdbDetailsPreview');

          if (trailerContainer) trailerContainer.innerHTML = '<p><em>Details not available for this title.</em></p>';
          if (titleElem) titleElem.textContent = item.title || item.name || 'Unknown';
          if (dateElem) dateElem.innerHTML = '';
          if (overviewElem) overviewElem.textContent = 'We could not load details from TMDb.';
          if (preview) preview.style.display = 'block';
          resolve(null);
          return;
        }
        resolve(data);
      })
      .withFailureHandler(() => {
        resolve(null);
      })
      .getTMDbDetails(item.id, isTV);
  });
}

/** Given a plain title (and optional year), fetch TMDb details with trailer and fill the preview box */
function showTMDbPreviewByTitle(title, year) {
  const preview = document.getElementById("tmdbDetailsPreview");
  const trailerContainer = document.getElementById("tmdbTrailerContainer");
  const titleEl = document.getElementById("tmdbDetailsTitle");
  const dateEl = document.getElementById("tmdbDetailsReleaseDate");
  const ovEl = document.getElementById("tmdbDetailsOverview");

  if (!preview) return;

  // Optimistic: show box immediately with loading stub
  preview.style.display = "block";
  if (trailerContainer) trailerContainer.innerHTML = `<p style="opacity:.8;">Loading trailer…</p>`;
  if (titleEl) titleEl.textContent = title || "Loading…";
  if (dateEl) dateEl.innerHTML = "";
  if (ovEl) ovEl.textContent = "";

  // 👇 NEW: once visible, scroll the preview into view (sticky header aware)
  // double RAF to ensure layout is settled on mobile
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      scrollSectionIntoView(preview, { offset: -80, behavior: 'smooth' });
    });
  });

google.script.run
  .withSuccessHandler((data) => {
    if (!data || data.error) {
      if (trailerContainer) trailerContainer.innerHTML = `<p><em>No trailer available.</em></p>`;
      if (titleEl) titleEl.textContent = title || "Unknown";
      if (dateEl) dateEl.innerHTML = "";
      if (ovEl) ovEl.textContent = "We could not load details from TMDb.";
      // Also reset button to a neutral disabled state
      const btn = document.getElementById("tmdbWatchNowBtn");
      if (btn) { btn.textContent = "Watch Now"; btn.style.background = "#00a7b0"; btn.onclick = null; }
      return;
    }

    const trailer = (data.videos?.results || []).find(v => v.type === "Trailer" && v.site === "YouTube");
    if (trailerContainer) {
      trailerContainer.innerHTML = trailer
        ? `<iframe id="tmdbTrailerFrame" src="https://www.youtube.com/embed/${trailer.key}"
              sandbox="allow-same-origin allow-scripts allow-presentation allow-popups allow-forms"
              allowfullscreen style="width:100%;height:100%;border:none;border-radius:12px;"></iframe>`
        : `<p><em>No trailer available.</em></p>`;

      // 👇 NEW: Scroll preview into view again after the iframe finishes loading.
      // Works even if the helper isn't defined anywhere yet.
      const frame = document.getElementById("tmdbTrailerFrame");
      if (frame) {
        const doScrollPreview = () => {
          const yOffset = -80; // adjust if your sticky header height changes
          const y = preview.getBoundingClientRect().top + window.scrollY + yOffset;
          window.scrollTo({ top: y, behavior: 'smooth' });
        };
        frame.addEventListener("load", () => {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              // Prefer global helper if you added it; otherwise use the local fallback.
              if (typeof scrollSectionIntoView === "function") {
                scrollSectionIntoView(preview, { offset: -80, behavior: 'smooth' });
              } else {
                doScrollPreview();
              }
            });
          });
        });
      }
    }

    const titleText = data.name || data.title || (title || "Unknown");
    if (titleEl) titleEl.textContent = titleText;
    if (dateEl) dateEl.innerHTML = `<strong>Release Date:</strong> ${data.first_air_date || data.release_date || "N/A"}`;
    if (ovEl) ovEl.textContent = data.overview || "No overview available.";


    // 👇 NEW: remember what’s in preview and configure the button
    _previewCurrentTitle = titleText;
    _previewLocalItem = findLocalByTitle(titleText);

    const btn = document.getElementById("tmdbWatchNowBtn");
    if (btn) {
      if (_previewLocalItem) {
        // Local (Recently Added / Available): WATCH NOW
        btn.textContent = "Watch Now";
        btn.style.background = "#00a7b0";
        btn.onclick = () => {
          showEpisodesList(_previewLocalItem);
        };
      } else {
        // Explore (TMDb only): ADD TO WISHLIST
        btn.textContent = "Add to Wishlist";
        btn.style.background = "#e50914";
        btn.onclick = (e) => {
          e.stopPropagation();
          addToWishlist(
            titleText,
            data.poster_path ? ('https://image.tmdb.org/t/p/w300' + data.poster_path) : '',
            btn
          );
        };
      }
    }
  })
  .withFailureHandler(() => {
    if (trailerContainer) trailerContainer.innerHTML = `<p><em>No trailer available.</em></p>`;
    if (titleEl) titleEl.textContent = title || "Unknown";
    if (dateEl) dateEl.innerHTML = "";
    if (ovEl) ovEl.textContent = "We could not load details from TMDb.";
    // Reset button to safe default
    const btn = document.getElementById("tmdbWatchNowBtn");
    if (btn) { btn.textContent = "Watch Now"; btn.style.background = "#00a7b0"; btn.onclick = null; }
  })
  .getTMDbDetailsByTitle(title, year || "");
}

const btn = document.getElementById("tmdbWatchNowBtn");
if (btn) {
  // Default label & style. Handler is assigned later by showTMDbPreviewByTitle().
  btn.textContent = "Watch Now";
  btn.style.background = "#00a7b0";
  btn.onclick = null;
}

const GENRES = { 
  comedy:'35', western:'37', action:'28', drama:'18', animation:'16', history:'36', scifi:'878' 
};

// NEW: load only the "Explore All" row
async function loadExploreAllRow() {
  const rowId = 'tmdbExploreAllRow';
  const row = document.getElementById(rowId);
  if (!row) return;
  row.classList.add('is-refreshing');
  try {
    await initExploreRow('', rowId); // '' = no genre filter (your “All” mixed row)
  } catch (e) {
    console.error('Explore All init failed:', e);
    row.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">Couldn’t load this list.</p>';
  } finally {
    row.classList.remove('is-refreshing');
  }
}

// Helpers for randomness (if you added these earlier)
function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
function randPage(max = 500) { return randInt(1, max); }

// Per-row lazy-load state for Explore sections
const exploreState = new Map(); // key = rowId, value = { genre, items:[], loaded:0, loading:false }

function _dedupe(items) {
  const seen = new Set();
  return (items || []).filter(it => {
    const key = `${it.id}|${it.media_type || (it.first_air_date ? 'tv' : 'movie')}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

async function initExploreRow(genre, rowId) {
  const rowEl = document.getElementById(rowId);
  if (!rowEl) return;

  // reset state
  exploreState.set(rowId, { genre, items: [], loaded: 0, loading: false });

  // show skeletons ONLY if the row is truly empty
  if (rowEl.children.length === 0) {
    rowEl.innerHTML = `
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    `;
  }

  const st = await ensureExploreBuffer(rowId, genre, 12);
  if (st && Array.isArray(st.items) && st.items.length) {
    _exploreCache.set(rowId, { genre, items: st.items.slice(), stamp: Date.now() });
  }

  // ⤵️ render off-screen, wait images, then swap (no empty frame)
  await renderExploreRowNoBlink(rowEl, rowId, 10);
}

// Helper to call Apps Script; returns [] on failure
function callScript(fn, ...args) {
  return new Promise(resolve => {
    try {
      google.script.run
        .withSuccessHandler(res => resolve(Array.isArray(res) ? res : []))
        .withFailureHandler(() => resolve([]))[fn](...args);
    } catch (_) {
      resolve([]);
    }
  });
}

async function fetchMixedTopRated(genreId, count = 12) {
  const ATTEMPTS = 3;         // how many random-page attempts per step
  const REGION   = 'US';
  const wanted   = Number(genreId || 0);

  let merged = [];

  // 1) Provider-filtered: random pages, multiple attempts
  for (let i = 0; i < ATTEMPTS && merged.length < count; i++) {
    const [m, t] = await Promise.all([
      callScript('getDiscoverByGenreTypeProviders', 'movie', randPage(), REGION, genreId || ''),
      callScript('getDiscoverByGenreTypeProviders', 'tv',    randPage(), REGION, genreId || '')
    ]);
    merged = _dedupe([...merged, ...(m || []), ...(t || [])]);
  }

  // 2) Fallback: genre-only (no provider filter), still random pages
  if (merged.length < count) {
    for (let i = 0; i < ATTEMPTS && merged.length < count; i++) {
      const [m, t] = await Promise.all([
        callScript('getDiscoverByGenreType', 'movie', randPage(), REGION, genreId || ''),
        callScript('getDiscoverByGenreType', 'tv',    randPage(), REGION, genreId || '')
      ]);
      merged = _dedupe([...merged, ...(m || []), ...(t || [])]);
    }
  }

  // 3) (Optional) Last fallback: trending BUT keep genre pure
  //    Remove this whole block if you want strict genre-only.
  if (merged.length < count) {
    const [m2, t2] = await Promise.all([
      callScript('getTrendingByType', 'movie', randPage()),
      callScript('getTrendingByType', 'tv',    randPage())
    ]);
    merged = _dedupe([...merged, ...(m2 || []), ...(t2 || [])])
      .filter(it => Array.isArray(it.genre_ids) && it.genre_ids.includes(wanted));
  }

  // Final: shuffle every time, then cap to `count`
  return shuffleArray(merged).slice(0, count);
}

// Make sure we have at least `need` items cached for this row
async function ensureExploreBuffer(rowId, genre, need = 10) {
  let st = exploreState.get(rowId);
  if (!st) {
    st = { genre, items: [], loaded: 0, loading: false };
    exploreState.set(rowId, st);
  }
  const missing = Math.max(0, need - (st.items.length - st.loaded));
  if (missing <= 0) return st;

  if (st.loading) return st; // someone else is fetching
  st.loading = true;
  try {
    // ask for a bit extra to keep things feeling fresh
    const batch = await fetchMixedTopRated(genre, Math.max(12, missing + 8));
    // merge + dedupe by id|type
    const merged = _dedupe([...st.items, ...batch]);
    st.items = merged;
  } finally {
    st.loading = false;
  }
  return st;
}

// Append up to `count` new cards to the row from its cache
function appendExploreItems(rowEl, rowId, count = 5) {
  const st = exploreState.get(rowId);
  if (!st || !st.items.length) return;

  const start = st.loaded;
  const end = Math.min(start + count, st.items.length);
  if (start >= end) return;

  const frag = document.createDocumentFragment();
  for (let i = start; i < end; i++) {
    frag.appendChild(createCard(st.items[i], true, wishlistRequestedTitles));
  }
  rowEl.appendChild(frag);
  st.loaded = end;
}

// SINGLE SOURCE OF TRUTH: genre sections/rows
const GENRE_ROWS = [
  { sectionId:'tmdbExploreComedySection',    rowId:'tmdbExploreComedyRow',    genre: GENRES.comedy,    label:'Comedy' },
  { sectionId:'tmdbExploreWesternSection',   rowId:'tmdbExploreWesternRow',   genre: GENRES.western,   label:'Western' },
  { sectionId:'tmdbExploreActionSection',    rowId:'tmdbExploreActionRow',    genre: GENRES.action,    label:'Action' },
  { sectionId:'tmdbExploreDramaSection',     rowId:'tmdbExploreDramaRow',     genre: GENRES.drama,     label:'Drama' },
  { sectionId:'tmdbExploreAnimationSection', rowId:'tmdbExploreAnimationRow', genre: GENRES.animation, label:'Animation' },
  { sectionId:'tmdbExploreHistorySection',   rowId:'tmdbExploreHistoryRow',   genre: GENRES.history,   label:'History' },
  { sectionId:'tmdbExploreScifiSection',     rowId:'tmdbExploreScifiRow',     genre: GENRES.scifi,     label:'Sci-Fi' }
];

/* Build Explore data/rows in the background WITHOUT changing visibility */
async function buildExploreFromDailyCache() {
  // 1) Fetch both pools from the nightly Apps Script cache
  const fetchSlice = (key, pool) => new Promise(res => {
    google.script.run
      .withSuccessHandler(d => res(d || {}))
      .withFailureHandler(() => res({}))
      .getTmdbDailySlice(key, 0, pool);
  });

  const [movies, tv] = await Promise.all([
    fetchSlice('browse_movie_popular', 300),
    fetchSlice('browse_tv_popular', 300)
  ]);

  // 2) Normalize, merge, de‑dupe, shuffle, cap
  const A = Array.isArray(movies.items) ? movies.items : [];
  const B = Array.isArray(tv.items) ? tv.items : [];
  const deduped = (() => {
    const seen = new Set();
    return [...A, ...B].filter(it => {
      const type = it.media_type || (it.first_air_date ? 'tv' : 'movie');
      const key  = `${it.id}|${type}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  })();

  const mixed = _shuffleCopy(deduped).slice(0, 24); // show up to 24 tiles

  // 3) Render into the single Explore row (no extra header injected)
  const row = document.getElementById('tmdbExploreAllRow');
  if (!row) return;
  row.innerHTML = '';
  const frag = document.createDocumentFragment();
  mixed.forEach(it => frag.appendChild(createCard(it, true, wishlistRequestedTitles)));
  row.appendChild(frag);

  try {
    console.log(`[Explore] ALL shuffled: pool=${A.length + B.length}, showing=${mixed.length}, updatedA=${movies.updatedAt || 'n/a'}, updatedB=${tv.updatedAt || 'n/a'}`);
  } catch (_) {}
}

let _exploreBuilt = false;
async function ensureExploreBuiltOnce() {
  if (_exploreBuilt) return;
  _exploreBuilt = true;
  try {
    await buildExploreFromDailyCache(); // ⬅️ new function below
  } catch (e) {
    console.warn('Explore (daily cache) failed:', e);
  }
}

// Small helpers
function _shuffleCopy(arr) {
  const a = (arr || []).slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function _sample(arr, n) {
  return _shuffleCopy(arr).slice(0, Math.max(0, Math.min(n || 20, 50)));
}

// Read a slice from the Apps Script daily cache and render it
function _loadDailyRow(listKey, rowId, title, requestCount = 20, pool = 200) {
  return new Promise((resolve) => {
    google.script.run
      .withSuccessHandler((data) => {
        const items = (data && data.items) || [];
        const picked = _sample(items, requestCount);
        // ✅ Debug: confirm cache plumbing
        try {
          console.log(`[Explore] ${listKey}: got ${items.length} in pool, showing ${picked.length} (updatedAt=${data?.updatedAt || 'n/a'})`);
        } catch (_) {}
        // Render
        try { hydrateExploreRow(rowId, title, picked); } catch (e) { console.warn(e); }
        resolve({ ok: true, count: picked.length, total: data.total || items.length });
      })
      .withFailureHandler((err) => {
        console.warn('Daily cache fetch failed for', listKey, err);
        resolve({ ok: false, count: 0, total: 0 });
      })
      .getTmdbDailySlice(listKey, 0, pool); // get a bigger pool, we sample client-side
  });
}

// Build all Explore rows from the prefilled daily cache
function buildExploreFromDailyCache() {
  // Just hydrate the “Explore All” row with a mix of movies + tv
  return Promise.all([
    _loadDailyRow('browse_movie_popular','tmdbExploreAllRow','Explore Movies'),
    _loadDailyRow('browse_tv_popular','tmdbExploreAllRow','Explore TV')
  ]);
}

// Renders a row given a container id, a title, and TMDb-like items
function hydrateExploreRow(rowId, _title, items) {
  // Use the existing scroll-container row and your createCard() template
  const rowEl = document.getElementById(rowId);
  if (!rowEl) {
    console.warn('hydrateExploreRow: container not found:', rowId);
    return;
  }

  // Clear current cards
  rowEl.innerHTML = '';

  // Build cards using your existing card component so styles & behavior match
  const frag = document.createDocumentFragment();
  (items || []).forEach(it => {
    // TMDb items: mark isTMDb=true so the + wishlist button appears
    const card = createCard(
      {
        id: it.id,
        title: it.title || it.name || 'Untitled',
        poster: it.poster ||
                (it.poster_path ? ('https://image.tmdb.org/t/p/w185' + it.poster_path) : ''),
        genre_ids: it.genre_ids || [],
        media_type: it.media_type || (it.first_air_date ? 'tv' : 'movie'),
        vote_average: it.vote_average
      },
      true, // isTMDb
      wishlistRequestedTitles
    );
    frag.appendChild(card);
  });

  rowEl.appendChild(frag);
}

async function showAllGenresAlways() {
  // Ensure every genre section is visible
  GENRE_ROWS.forEach(({ sectionId }) => {
    const sec = document.getElementById(sectionId);
    if (sec) sec.style.display = 'block';
  });

  // Prime each row with its first batch of titles
  await Promise.all(
    GENRE_ROWS.map(cfg => initExploreRow(cfg.genre, cfg.rowId))
  );

  // Prewarm next batches so refresh feels instant
  prewarmExploreRow('tmdbExploreAllRow',       '',               16);
  prewarmExploreRow('tmdbExploreComedyRow',    GENRES.comedy,    16);
  prewarmExploreRow('tmdbExploreWesternRow',   GENRES.western,   16);
  prewarmExploreRow('tmdbExploreActionRow',    GENRES.action,    16);
  prewarmExploreRow('tmdbExploreDramaRow',     GENRES.drama,     16);
  prewarmExploreRow('tmdbExploreAnimationRow', GENRES.animation, 16);
  prewarmExploreRow('tmdbExploreHistoryRow',   GENRES.history,   16);
  prewarmExploreRow('tmdbExploreScifiRow',     GENRES.scifi,     16);
}

// Button visual modes
function setSidebarBtnState(btn, mode = 'show', labelText = 'Show', rowId = '') {
  if (!btn) return;
  if (mode === 'show') {
    btn.innerHTML = `<i class="fa-solid fa-eye"></i><span>Show</span>`;
    btn.setAttribute('aria-label', `Show ${rowId}`);
  } else { // refresh
    btn.innerHTML = `<i class="fa-solid fa-rotate"></i><span>Refresh</span>`;
    btn.setAttribute('aria-label', `Refresh ${rowId}`);
  }
}

/* === Inline title actions (replace the old sidebar column) ================= */

function _findTitleForGrid(grid) {
  if (!grid) return null;
  const prev = grid.previousElementSibling;
  if (prev && (prev.classList?.contains('subsection-title') || prev.classList?.contains('section-title') || prev.classList?.contains('tmdb-title'))) {
    return prev;
  }
  // Episodes title has a fixed id
  const epiTitle = document.getElementById('episodesTitle');
  if (epiTitle && grid.id === 'episodesGrid') return epiTitle;

  // Fallback: search upward for nearest heading
  return grid.closest('.my-genre-block')?.querySelector('.subsection-title') || null;
}

/* If this grid lives in an old .list-row wrapper, unwrap it (remove the sidebar) */
function _unwrapLegacySidebarIfPresent(grid) {
  const wrap = grid?.parentNode;
  if (wrap && wrap.classList && wrap.classList.contains('list-row')) {
    // move grid out, drop wrapper
    const parent = wrap.parentNode;
    if (parent) {
      parent.insertBefore(grid, wrap);
      try { wrap.remove(); } catch(_) { parent.removeChild(wrap); }
    }
  }
}

/* Set icon/label for the inline action button */
function setTitleBtnState(btn, mode = 'show', rowId = '') {
  if (!btn) return;
  if (mode === 'show') {
    btn.innerHTML = `<i class="fa-solid fa-eye" aria-hidden="true"></i><span>Show</span>`;
    btn.setAttribute('aria-label', `Show ${rowId || 'list'}`);
  } else {
    btn.innerHTML = `<i class="fa-solid fa-rotate" aria-hidden="true"></i><span>Refresh</span>`;
    btn.setAttribute('aria-label', `Refresh ${rowId || 'list'}`);
  }
}

/* New: add an inline action button inside the title, directly to the left of the text */
function addTitleAction(gridId, onClick, initialLabel = 'Refresh', ariaLabel) {
  const grid = document.getElementById(gridId);
  if (!grid) return null;

  // If this grid was previously wrapped in the sidebar layout, unwrap it.
  _unwrapLegacySidebarIfPresent(grid);

  // Find the matching title node
  const titleEl = _findTitleForGrid(grid);
  if (!titleEl) return null;

  // Avoid duplicates
  if (titleEl._inlineActionBtn) return titleEl._inlineActionBtn;

  // Build a small inline button
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'title-action';
  btn.setAttribute('role', 'button');
  btn.setAttribute('tabindex', '0');
  btn.setAttribute('aria-label', ariaLabel || initialLabel);

  // Default visual (we’ll let callers switch to "Show" when needed)
  btn.innerHTML = `<i class="fa-solid fa-rotate" aria-hidden="true"></i><span>${initialLabel}</span>`;

  // Wire it
  let busy = false;
  btn._dynamicHandler = onClick;
  const run = async () => {
    if (busy) return;
    busy = true;
    btn.setAttribute('aria-busy','true');
    try {
      if (typeof btn._dynamicHandler === 'function') {
        await btn._dynamicHandler();
      }
    } finally {
      busy = false;
      btn.removeAttribute('aria-busy');
    }
  };
  btn.addEventListener('click', run);
  btn.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); run(); }
  });

  // Insert as the very first thing inside the title
  titleEl.insertBefore(btn, titleEl.firstChild);
  titleEl._inlineActionBtn = btn;

  // For convenience, also expose on the grid (similar to your old pattern)
  grid._sidebarAttached = true;      // compatibility flag used elsewhere
  grid._sidebarBtn = btn;

  return btn;
}

/* Backwards-compatible shim: keep your existing calls working */
function addSidebarRefresh(gridId, onClick, label = 'Refresh', ariaLabel) {
  return addTitleAction(gridId, onClick, label, ariaLabel);
}

/* Back-compat for callers that expect this name */
function setSidebarBtnState(btn, mode = 'show', _labelText = 'Show', rowId = '') {
  setTitleBtnState(btn, mode, rowId);
}

/* Map each list to its own refresh action */
function attachAllListSidebars() {

  addSidebarRefresh(
    'availableToWatchGrid',
    async () => {
      await refreshAvailableToWatch({ force: true });   // always pull fresh 10 from Drive
    },
    'Refresh',
    'Refresh Available to Watch'
  );

  // Wishlist
  addSidebarRefresh(
    'wishlistGrid',
    async () => { await loadWishlist(); },
    'Refresh',
    'Refresh Wishlist'
  );

    // Explore — All (always available; simple refresh)
    addSidebarRefresh(
      'tmdbExploreAllRow',
      async () => {
        const row = document.getElementById('tmdbExploreAllRow');
        if (row && row.children.length === 0) {
          row.classList.add('is-refreshing');
          try { await initExploreRow('', 'tmdbExploreAllRow'); }
          finally { row.classList.remove('is-refreshing'); }
        }
        await refreshExploreRowSmooth('tmdbExploreAllRow', '');
      },
      'Refresh',
      'Refresh Explore All'
    );

  GENRE_ROWS.forEach(cfg => {
    const btn = addSidebarRefresh(
      cfg.rowId,
      async () => { await refreshExploreRowSmooth(cfg.rowId, cfg.genre); },
      'Refresh',
      `Refresh ${cfg.rowId}`
    );
    if (btn) setSidebarBtnState(btn, 'refresh', 'Refresh', cfg.rowId);
  });
}

function loadWishlistRequested() {
  // Backward-compatible shim; use ensureWishlistAll internally
  return ensureWishlistAll().then(() => {});
}

function checkStickyShadow() {
  const stickyOffset = 100;  // or your preferred threshold
  const titles = document.querySelectorAll('.section-title, .tmdb-title');
  titles.forEach(el => {
    const rect = el.getBoundingClientRect();
    if (rect.top <= stickyOffset) {
      el.classList.add('sticky-shadow');
    } else {
      el.classList.remove('sticky-shadow');
    }
  });
}

let _myGenresRevealed = false;
function revealMyGenres({ show = false } = {}) {
  try {
    renderMyGenres();
    const sec = document.getElementById("myGenresSection");
    const hdr = document.getElementById("myGenresHeader");

    if (show) {
      if (hdr) hdr.style.display = "block";
      if (sec) sec.style.display = "block";
      _myGenresRevealed = true;
    } else {
      if (!_myGenresRevealed) {
        if (hdr) hdr.style.display = "none";
        if (sec) sec.style.display = "none";
      }
    }
  } catch (e) {
    console.warn("revealMyGenres failed:", e);
  }
}

// Toggle Available by Genre visibility (no header required)
document.addEventListener("DOMContentLoaded", () => {
  const btn = document.getElementById("viewByGenreBtn");
  const section = document.getElementById("myGenresSection");

  if (btn && section) {
    btn.addEventListener("click", () => {
      _myGenresRevealed = true;           // keep state in sync
      revealMyGenres({ show: true });     // shows + renders
      btn.style.display = "none";         // hide the button after reveal
      section.scrollIntoView({ behavior: "smooth" });
    });
  }
});

window.addEventListener('scroll', checkStickyShadow);
window.addEventListener('load', checkStickyShadow);

waitForImagesToLoad(document.getElementById('appContent')).then(() => {
});

let libraryLoaded = false;
</script>
</body>
</html>
