<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ILYMMD+</title>

  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" as="style">
  <link rel="preload" href="https://i.postimg.cc/HkMtCdMK/ILYMMD-8-4-2025.png" as="image">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" media="all" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"></noscript>
  <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"></noscript>

<style>
/* =======================
   GLOBAL BASE STYLES
   ======================= */
:root {
  /* spacing & sizes you might tweak later */
}

body {
  font-family: Arial, sans-serif;
  background: #141414;
  color: #fff;
  margin: 0;
  font-size: 60px; /* mobile default */
}

#appContent {
  padding-top: 0;         /* header is static */
  padding-bottom: 120px;  /* make room for bottom bar */
}

/* =======================
   HEADER
   ======================= */
header {
  background: #000;
  box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  text-align: center;
  position: relative;
  z-index: 1;
}
header img {
  max-width: 350px;
  height: auto;
}

/* =======================
   EPISODES (compact cards)
   ======================= */
.active-episode {
  outline: 3px solid #00a7b0;
  outline-offset: 2px;
}
#episodesSection .movie-card {
  flex: 0 0 90px;
  max-width: 90px;
  margin: 3px;
}
#episodesSection .movie-poster {
  width: 100%;
  height: auto;
}
#episodesSection .movie-title {
  font-size: 0.65rem;
  line-height: 1.1;
  padding: 4px;
}
#episodesSection .scroll-container {
  gap: 8px;
}

/* Ensure the trailer area is on top and interactive */
#tmdbTrailerContainer { position: relative; z-index: 1; }

/* Just in case: never disable pointer events on the preview or the container */
#tmdbDetailsPreview, #tmdbTrailerContainer, #tmdbTrailerFrame {
  pointer-events: auto !important;
}

/* =======================
   PROFILES
======================= */

#switchProfileBtn {
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
}

#switchProfileBtn img {
  border-radius: 50%; /* circular icon */
}

.profile-btn {
  background: #1f1f1f;
  color: #fff;
  font-size: 30px;
  border: none;
  padding: 20px;
  border-radius: 20px;
  cursor: pointer;
  transition: background 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px; /* space between icon and name */
}

.profile-btn img {
  width: 100px;   /* icon size */
  height: 100px;
  border-radius: 50%; /* round icons */
  object-fit: cover;
}

.profile-btn:hover { 
  background: #00a7b0; 
}

/* =======================
   SEARCH BAR
   ======================= */
.search-bar {
  position: sticky;
  top: 0;
  left: 0;
  width: 100%;
  height: 55px;
  background: #141414;
  padding: 10px 0;
  text-align: center;
  z-index: 10000;
}
.search-bar input {
  padding: 40px;
  width: 95%;
  max-width: 750px;
  font-size: 60px;
  border-radius: 12px;
  border: none;
}

/* =======================
   SECTION / TITLE HEADERS
   ======================= */
.section-title,
.tmdb-title {
  font-family: 'Roboto', sans-serif;
  font-weight: 700;
  font-size: 90px;
  text-align: center;
  color: #fff;
  position: sticky;
  top: 55px; /* height of search bar */
  background: #141414;
  z-index: 9999;
  padding-top: 30px;
  letter-spacing: 0.05em;
}
.section-title { margin: 80px auto 5px; }
.tmdb-title     { margin: 80px auto 40px; }

.section-title::before,
.tmdb-title::before {
  content: "";
  display: block;
  width: 100px;
  height: 6px;
  background-color: #00a7b0;
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  border-radius: 3px;
}

.subsection-title {
  font-family: 'Roboto', sans-serif;
  font-size: 80px;
  margin: 40px auto 20px;
  padding: 50px 20px 10px;
}

/* =======================
   SCROLL CONTAINERS
   ======================= */
.scroll-container {
  display: flex;
  gap: 30px;
  overflow-x: auto;
  padding: 0 20px 10px;
  position: relative; /* needed for seamless refresh overlay */
}
.scroll-container::-webkit-scrollbar { display: none; }

/* --- Seamless refresh overlay: keep content visible while fetching --- */
.scroll-container.is-refreshing::after {
  content: "";
  position: absolute; inset: 0;
  background: linear-gradient(0deg, rgba(20,20,20,0) 0%, rgba(20,20,20,0.25) 100%);
  pointer-events: none;
  border-radius: 0; /* inherits the container shape */
}
.scroll-container.is-refreshing::before {
  content: "";
  position: absolute; top: 12px; right: 12px;
  width: 18px; height: 18px; border-radius: 50%;
  border: 3px solid #666; border-top-color: #e50914;
  animation: spin .8s linear infinite;
  pointer-events: none;
  z-index: 1;
}

/* =======================
   CARDS & ITEMS
   ======================= */
.movie-card,
.movie-item { border-radius: 12px; cursor: pointer; }

.movie-card {
  background: #1f1f1f;
  overflow: hidden;
  width: 350px;
  flex: 0 0 auto;
  position: relative;
  transition: none !important;
}
.movie-card:hover { transition: none !important; }

.movie-card img,
.movie-item img {
  width: 100%;
  display: block;
  border-radius: 12px;
}

.movie-title {
  padding: 24px;
  text-align: center;
  font-size: 60px;
}

/* Add / Request button on TMDb cards */
.add-btn {
  position: absolute;
  top: 12px;
  right: 12px;
  background: #e50914;
  color: #fff;
  border: none;
  border-radius: 50%;
  width: 100px;
  height: 100px;
  font-size: 80px;
  line-height: 96px;
  cursor: pointer;
  z-index: 10;
  transition: background 0.3s ease;
}
.add-btn:hover { background: #ff4c4c; }

/* =======================
   SKELETON LOADER
   ======================= */
.skeleton-card {
  width: 350px;
  height: 450px;
  background: #2c2c2c;
  border-radius: 12px;
  animation: pulse 1.2s infinite;
}
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.6} }

/* =======================
   LOADING OVERLAY
   ======================= */
#loadingScreen {
  position: fixed;
  inset: 0;
  background: #141414;
  color: #fff;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  font-family: 'Roboto', sans-serif;
  font-size: 60px;
  z-index: 2147483647;
}

.loader {
  border: 12px solid #333;
  border-top: 12px solid #e50914;
  border-radius: 50%;
  width: 80px;
  height: 80px;
  animation: spin 1s linear infinite;
}
@keyframes spin { 0%{transform:rotate(0)} 100%{transform:rotate(360deg)} }

/* Inline loading label used next to buttons */
.loading-text {
  display: none;             /* hidden by default */
  font-weight: bold;
  color: #e50914;
  vertical-align: middle;
  margin-left: 8px;
  font-size: 24px;           /* base size, overridden in media queries */
}
.add-refresh-btn.loading + .loading-text { display: inline; }

/* Base style for the remove (–) button */
.cw-complete-btn {
  position: absolute;
  top: 8px;
  right: 8px;
  width: 28px;
  height: 28px;
  font-size: 18px;
  line-height: 1;
  border: none;
  border-radius: 50%;
  background-color: rgba(0,0,0,0.7);
  color: white;
  cursor: pointer;
  z-index: 3;
}

.cw-complete-btn:hover {
  transform: scale(1.06);
  background: #ff4c4c; /* brighter red on hover */
}

.cw-complete-btn:disabled {
  opacity: .6;
  cursor: default;
}

/* =======================
   NAV / BOTTOM BAR
   ======================= */
.bottom-bar {
  position: fixed;
  bottom: 0; left: 0;
  width: 100%;
  background: #000;
  display: flex;
  justify-content: space-around;
  padding: 10px 0;
  border-top: 1px solid #222;
  z-index: 9999;
}
.nav-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  color: #fff;
  font-size: 40px;
  cursor: pointer;
}
.nav-item i { font-size: 56px; margin-bottom: 8px; }
.nav-item:hover { color: #aaa; }

/* Refresh emoji (used in a few places) */
.refresh-emoji {
  cursor: pointer;
  user-select: none;
  font-size: 30px;           /* overridden in media queries */
  margin-left: 10px;
  vertical-align: middle;
  display: inline-block;
  transition: color 0.3s ease;
}
.refresh-emoji:hover,
.refresh-emoji:focus { color: #ff4c4c; outline: none; }
.refresh-emoji[aria-disabled="true"] {
  color: gray;
  cursor: default;
  pointer-events: none;
}

/* Episodes row controls */
.episodes-close {
  font-size: 0.9em;
  margin-left: 12px;
  padding: 6px 12px;
  border: none;
  border-radius: 8px;
  background: #333;
  color: #fff;
  cursor: pointer;
}
.episodes-close:hover { background: #444; }

/* =======================
   MODALS
   ======================= */
.modal {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.95);
  justify-content: center;
  align-items: center;
  z-index: 2147483646;
  padding: 0;
}
.modal.active { display: flex !important; }

.modal-content {
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 95vw;
  max-height: 80vh;
  background: #1f1f1f;
  overflow: hidden;
  border-radius: 12px;
}

/* =======================
   TEXT IN MODAL
   ======================= */
.movie-title-text {
  font-family: 'Roboto', sans-serif;
  font-weight: 700;
  font-size: 70px;
  margin-bottom: 30px;
  color: #fff;
  text-transform: uppercase;
}
.movie-overview {
  font-size: 40px !important;
  line-height: 1.8;
  color: #aaa;
  margin-bottom: 40px;
}

/* =======================
   POPUP
   ======================= */
#customPopup {
  display: none;
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: #222;
  color: #fff;
  padding: 30px 50px;
  border-radius: 15px;
  box-shadow: 0 0 20px rgba(0,0,0,0.8);
  font-size: 28px;
  z-index: 2147483646 !important;
  max-width: 90vw;
  text-align: center;
  width: 500px;
  box-sizing: border-box;
}

/* =======================
   MISC
   ======================= */
.sticky-shadow {
  box-shadow: 0 2px 5px rgba(0,0,0,0.7);
  transition: box-shadow 0.3s ease;
}

.movie-card.last-watched {
  position: relative; /* ensure overlay anchors correctly */
}

.movie-card.last-watched::after {
  content: "Last watched";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  text-align: center;
  background: rgba(0, 167, 176, 0.92);
  color: #fff;
  font-weight: normal;
  padding: 14px 16px;
  border-radius: 12px 12px 0 0;
  z-index: 2;
  pointer-events: none;
  font-size: 15px;
}

/* =======================
   RESPONSIVE: MOBILE
   ======================= */
@media (max-width: 999px) {
  body { font-size: 30px !important; }

  #mobileRefreshButtonsContainer {
    display: flex !important;
    gap: 20px;
    justify-content: center;
    align-items: center;
  }

  .profile-btn img {
    width: 150px;
    height: 150px;
  }

  .movie-card.last-watched::after {
    font-size: 40px;        /* larger text for mobile */
    padding: 14px 16px;     /* taller banner for readability */
  }

  .cw-complete-btn {
    width: 100px !important;
    height: 100px !important;
    font-size: 80px !important;
    line-height: 96px !important;
  }

  #loadingScreen { font-size: 60px !important; }
  header img { max-width: 350px !important; }
  .search-bar input { font-size: 40px !important; }

  .section-title,
  .tmdb-title { box-shadow: none; transition: box-shadow 0.3s ease; }

  .sticky-shadow { box-shadow: 0 2px 5px rgba(0,0,0,0.7); }

  .section-title,
  .tmdb-title {
    font-size: 55px !important;
    margin: 60px auto 40px auto !important;
    padding-top: 24px !important;
    position: sticky !important;
    top: 55px !important;
    background: #141414 !important;
    z-index: 9999 !important;
  }
  .section-title { margin-bottom: 5px !important; }

  .section-title::before,
  .tmdb-title::before { width: 80px !important; height: 5px !important; }

  .subsection-title {
    font-size: 40px !important;
    padding: 30px 20px 10px;
  }

  .movie-card { width: 350px !important; }
  .movie-title { font-size: 40px !important; padding: 24px !important; }
  .skeleton-card { width: 350px !important; height: 450px !important; }

  .modal-content {
    flex-direction: column !important;
    max-width: 95vw !important;
    max-height: 80vh !important;
  }
  #videoFrameContainer { flex: 1 1 100% !important; min-height: 300px !important; width: 100% !important; }
  .movie-info-scroll { flex: 1 1 100% !important; width: 100% !important; padding: 30px !important; }

  .refresh-emoji { font-size: 50px; }

  .movie-title-text { font-size: 70px !important; margin-bottom: 30px !important; }
  .movie-rating { font-size: 20px !important; margin-bottom: 20px !important; }
  .movie-overview { font-size: 30px !important; margin-bottom: 40px !important; }

  .loading-text { font-size: 40px !important; }

  .add-btn {
    width: 100px !important;
    height: 100px !important;
    font-size: 80px !important;
    line-height: 96px !important;
  }

  #customPopup {
    width: 90vw;
    padding: 40px 30px;
    font-size: 50px !important;
    top: 15%;
  }
  #popupCloseBtn { font-size: 50px !important; padding: 14px 40px; }
}

/* =======================
   RESPONSIVE: DESKTOP
   ======================= */
@media (min-width: 1000px) {
  body { font-size: 15px !important; }
  #loadingScreen { font-size: 20px !important; }
  header img { max-width: 150px !important; }
  .search-bar input { padding: 10px !important; font-size: 20px !important; }

  .nav-item { font-size: 15px !important; }
  .nav-item i { font-size: 20px !important; }

  .add-btn {
    width: 40px !important;
    height: 40px !important;
    font-size: 20px !important;
    line-height: 36px !important;
  }

  .refresh-emoji { font-size: 25px; }

  .loading-text { font-size: 15px !important; }

  #mobileRefreshButtonsContainer {
    display: flex !important;
    width: 100%;
    justify-content: space-around;
    align-items: center;
  }

  .section-title,
  .tmdb-title {
    font-size: 35px !important;
    margin: 40px auto 20px auto !important;
    padding-top: 12px !important;
    position: sticky !important;
    top: 55px !important;
    background: #141414 !important;
    z-index: 9999 !important;
  }
  .section-title { margin-bottom: 5px !important; }

  .section-title::before,
  .tmdb-title::before { width: 60px !important; height: 4px !important; }

  .subsection-title {
    margin: 0 !important;
    font-size: 20px !important;
    padding: 30px 20px 10px;
  }

  .movie-title { font-size: 15px !important; padding: 4px !important; }
  .movie-card { width: 150px !important; }
  .movie-card:hover { transform: none !important; }
  .skeleton-card { width: 150px !important; height: 200px !important; }

  .movie-info-scroll { padding: 10px !important; }
  .movie-title-text { font-size: 20px !important; margin-bottom: 10px !important; }
  .movie-rating { font-size: 15px !important; margin-bottom: 5px !important; }
  .movie-overview { font-size: 15px !important; margin-bottom: 10px !important; }

  .modal-content { max-width: 90vw !important; max-height: 70vh !important; }
  #videoFrameContainer { min-height: 150px !important; }

  /* visible scrollbars for desktop */
  .scroll-container { scrollbar-width: thin; scrollbar-color: #888 #1f1f1f; }
  .scroll-container::-webkit-scrollbar { height: 12px; }
  .scroll-container::-webkit-scrollbar-track { background: #1f1f1f; border-radius: 6px; }
  .scroll-container::-webkit-scrollbar-thumb { background: #888; border-radius: 6px; }
  .scroll-container::-webkit-scrollbar-thumb:hover { background: #aaa; }
}

/* Disable hover scaling on touch devices */
@media (hover: none) and (pointer: coarse) {
  .movie-card:hover {
    transform: none !important;
  }
}

/* Keep the nice hover scale on real-hover devices (mice/trackpads) */
@media (hover: hover) and (pointer: fine) {
  .movie-card:hover {
    transform: none !important;
  }
}
</style>
</head>
<body>

<div id="profileModal" class="modal active" role="dialog" aria-modal="true">
  <div class="modal-content" style="align-items:center; justify-content:center; text-align:center; padding: 50px;">
    <h2 style="font-size: 60px; margin-bottom: 40px;">Who's watching?</h2>
    <div id="profileList" style="display: flex; gap: 40px; flex-wrap: wrap; justify-content: center;">    
      <button class="profile-btn" data-profile="Dave">
        <img src="https://i.postimg.cc/nVvJZm7y/dave.png" alt="Dave">
        <span>Dave</span>
      </button>    
      <button class="profile-btn" data-profile="Melissa">
        <img src="https://i.postimg.cc/htGW93wn/melissa.png" alt="Melissa">
        <span>Melissa</span>
      </button>
    
      <button class="profile-btn" data-profile="Ben">
        <img src="https://i.postimg.cc/D0K3LfVp/ben.jpg" alt="Ben">
        <span>Ben</span>
      </button>      
      <button class="profile-btn" data-profile="Kassandra">
        <img src="https://i.postimg.cc/Fzg5ZtNr/kassandra.jpg" alt="Kassandra">
        <span>Kassandra</span>
      </button>     
      <button class="profile-btn" data-profile="Aiden">
        <img src="https://i.postimg.cc/JhvL7cpL/aiden.png" alt="Aiden">
        <span>Aiden</span>
      </button>
      <button class="profile-btn" data-profile="Liadan">
        <img src="https://i.postimg.cc/RZbrGL5H/liadan.png" alt="Liadan">
        <span>Liadan</span>
      </button>
    </div>
  </div>
</div>

<div id="appContent" style="display: none;">

  <!-- App Content -->
  <header><br><br><img src="https://i.postimg.cc/HkMtCdMK/ILYMMD-8-4-2025.png" alt="ILYMMD+ Logo"><br><br></header>
  <div class="search-bar"><input type="text" id="searchInput" placeholder="Search movies or shows..."></div>

  <!-- Watch Header -->
  <h2 class="section-title">Available to Watch</h2>

  <!-- Episodes -->
  <div id="episodesSection" style="display:none;">
    <h2 class="subsection-title" id="episodesTitle"></h2>
    <div class="scroll-container" id="episodesGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- Continue Watching Section -->
  <div id="continueWatchingSection">
    <h2 class="subsection-title">Continue Watching</h2>
    <div class="scroll-container" id="continueWatchingGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- Recently Available Section -->
  <div id="recentlyAddedSection">
    <h2 class="subsection-title">Recently Added & Available</h2>
    <div class="scroll-container" id="recentlyAddedGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- All Available Section -->
  <div id="availableToWatchSection">
    <h2 class="subsection-title">All Available Movies & TV Shows</h2>
    <!-- Placeholders while loading -->
    <div class="scroll-container" id="availableToWatchGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <h2 class="tmdb-title">Explore</h2>

  <div id="tmdbDetailsPreview" 
      style="max-width: 900px; margin: 20px auto; background: #1f1f1f; border-radius: 12px; padding: 20px; color: white; display:none;">
    <div id="tmdbTrailerContainer" style="width: 100%; height: 450px; margin-bottom: 20px;"></div>
    <h2 class="movie-title-text" id="tmdbDetailsTitle"></h2>
    <p id="tmdbDetailsReleaseDate"></p>
    <p class="movie-overview" id="tmdbDetailsOverview"></p>
  </div>

  <div id="tmdbExploreAllSection">
    <h2 class="subsection-title">Explore All</h2>
    <div class="scroll-container" id="tmdbExploreAllRow"></div>
  </div>

  <div id="tmdbExploreComedySection">
    <h2 class="subsection-title">Explore Comedy</h2>
    <div class="scroll-container" id="tmdbExploreComedyRow"></div>
  </div>

  <div id="tmdbExploreWesternSection">
    <h2 class="subsection-title">Explore Western</h2>
    <div class="scroll-container" id="tmdbExploreWesternRow"></div>
  </div>

  <div id="tmdbExploreActionSection">
    <h2 class="subsection-title">Explore Action</h2>
    <div class="scroll-container" id="tmdbExploreActionRow"></div>
  </div>

  <div id="tmdbExploreDramaSection">
    <h2 class="subsection-title">Explore Drama</h2>
    <div class="scroll-container" id="tmdbExploreDramaRow"></div>
  </div>

  <div id="tmdbExploreAnimationSection">
    <h2 class="subsection-title">Explore Animation</h2>
    <div class="scroll-container" id="tmdbExploreAnimationRow"></div>
  </div>

  <div id="tmdbExploreHistorySection">
    <h2 class="subsection-title">Explore History</h2>
    <div class="scroll-container" id="tmdbExploreHistoryRow"></div>
  </div>

  <div id="tmdbExploreRomanceSection">
    <h2 class="subsection-title">Explore Romance</h2>
    <div class="scroll-container" id="tmdbExploreRomanceRow"></div>
  </div>

  <div id="tmdbExploreScifiSection">
    <h2 class="subsection-title">Explore Sci-Fi</h2>
    <div class="scroll-container" id="tmdbExploreScifiRow"></div>
  </div>

  <!-- Wishlist Section -->
  <div id="wishlistSection">
    <h2 class="subsection-title">Wishlist</h2>
    <div class="scroll-container" id="wishlistGrid">
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    </div>
  </div>

  <!-- Search Results -->
  <div id="searchResultsSection" style="display:none;">
    <h2 class="subsection-title">Search Results</h2>
    <div class="scroll-container" id="searchResultsGrid"></div>
  </div>

  <!-- Custom Popup -->
  <div id="customPopup" role="status" aria-live="polite" aria-atomic="true" style="display:none; position: fixed; top: 20%; left: 50%; transform: translateX(-50%); background: #222; color: white; padding: 30px 50px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.8); font-size: 28px; z-index: 3000; max-width: 90vw; text-align: center;">
    <span id="popupMessage"></span>
    <button id="popupCloseBtn" style="display:block; margin: 20px auto 0 auto; padding: 10px 30px; font-size: 24px; border: none; border-radius: 8px; background: #e50914; color: white; cursor: pointer;">Close</button>
  </div>

  <div class="bottom-bar">
    <div id="mobileRefreshButtonsContainer" style="display:none; width: 100%; justify-content: space-around;">
      <div class="nav-item" id="mobileAvailableRefresh" role="button" tabindex="0" aria-label="Refresh Available to Watch">
        <i class="fa-solid fa-rotate"></i><span>Available</span>
      </div>
      <div class="nav-item" id="switchProfileBtn" role="button" tabindex="0" aria-label="Switch Profile">
        <img id="currentProfileIcon" src="https://via.placeholder.com/50" alt="Profile" style="width:50px;height:50px;object-fit:cover;border-radius:50%;margin-bottom:5px;">
        <span id="currentProfileName">Profile</span>
      </div>
      <div class="nav-item" id="mobileExploreRefresh" role="button" tabindex="0" aria-label="Refresh Explore">
        <i class="fa-solid fa-rotate"></i><span>Explore</span>
      </div>
    </div>
  </div>

</div>

<div id="loadingScreen" style="
  font-family: 'Roboto', sans-serif;
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0, 0, 0, 0.85);
  color: white;
  font-size: 48px;
  align-items: center;
  justify-content: center;
  z-index: 2147483647;
  pointer-events: auto; /* blocks clicks while visible */
  cursor: wait;
">
  Loading...
</div>

<script>
let fullLibrary = [];
let wishlistAvailableTitles = [];
let wishlistRequestedTitles = [];

let _wishlistAllCachePromise;
function ensureWishlistAll() {
  if (!_wishlistAllCachePromise) {
    _wishlistAllCachePromise = new Promise(res => {
      google.script.run
        .withSuccessHandler(items => {
          items = items || [];
          const norm = s => String(s || '').trim().toLowerCase();
          wishlistRequestedTitles = items.filter(x => norm(x.status) === "wishlist");
          wishlistAvailableTitles = items.filter(x => norm(x.status) === "available");
          res(items);
        })
        .withFailureHandler(() => res([]))
        .getWishlistAllWithStatus();
    });
  }
  return _wishlistAllCachePromise;
}

const appContent = document.getElementById('appContent');

let _lastFocus = null;

function selectProfile(profileName, iconUrl) {
  // Set current profile
  currentProfile = profileName;

  // Update bottom bar button
  const nameEl = document.getElementById("currentProfileName");
  const iconEl = document.getElementById("currentProfileIcon");
  if (nameEl) nameEl.textContent = currentProfile || "Profile";
  if (iconEl) iconEl.src = iconUrl || "https://via.placeholder.com/50";

  // Persist for next visit
  try {
    localStorage.setItem("lastProfileName", currentProfile);
    if (iconEl && iconEl.src) localStorage.setItem("lastProfileIcon", iconEl.src);
  } catch (e) {
    console.warn("localStorage unavailable:", e);
  }

  // Proceed just like your existing click handler
  const profileModal = document.getElementById("profileModal");
  const app = document.getElementById("appContent");
  profileModal.classList.remove("active");
  app.style.display = "block";
  loadingScreen.style.display = "flex"; // show while CW loads

  // 1) Load Continue Watching first; hide loader as soon as it's ready
  loadContinueWatching()
    .then(() => {
      const cw = document.getElementById("continueWatchingSection");
      if (cw) cw.style.display = "block";
      hideLoadingScreen(0);
    })
    .catch(err => {
      console.error("❌ Error loading Continue Watching:", err);
      hideLoadingScreen(0);
    });

  // 2) Ensure wishlist cache once, then load the 3 sections
  ensureWishlistAll()
    .then(() => Promise.all([ loadExploreRows(), loadWishlist() ]))
    .then(() => {
      const wl = document.getElementById("wishlistSection");
      const ra = document.getElementById("recentlyAddedSection");
      if (wl) wl.style.display = "block";
      if (ra) ra.style.display = "block";
      return waitForImagesToLoad(app, { timeoutMs: 2500 });
    })
    .catch(err => {
      console.error("❌ Error during background loads:", err);
      showPopup("Some items are still loading. Try again if they don't appear.");
    });
}

function showPopup(messageHtml) {
  _lastFocus = document.activeElement;
  const popup = document.getElementById('customPopup');
  const msgSpan = document.getElementById('popupMessage');
  msgSpan.innerHTML = messageHtml;
  popup.style.display = 'block';
  document.getElementById('popupCloseBtn').focus();
}

document.getElementById('popupCloseBtn').addEventListener('click', () => {
  document.getElementById('customPopup').style.display = 'none';
  if (_lastFocus && typeof _lastFocus.focus === 'function') {
    _lastFocus.focus();
  }
});

document.addEventListener('keydown', (e) => {
  const popup = document.getElementById('customPopup');
  if (e.key === 'Escape' && popup.style.display === 'block') {
    document.getElementById('popupCloseBtn').click();
  }
});

// Remove an item from Continue Watching for this profile
function markComplete(profile, title, cardEl, episode = "") {
  if (!profile || !title) return;

  // Optimistic UI: disable button + fade card a bit
  const btn = cardEl.querySelector('.cw-complete-btn');
  if (btn) btn.disabled = true;
  cardEl.style.opacity = '0.6';

  google.script.run
    .withSuccessHandler(res => {
      // Remove the card from the UI
      cardEl.remove();

      // If the row goes empty, show the empty state
      const container = document.getElementById("continueWatchingGrid");
      if (container && container.children.length === 0) {
        container.innerHTML = "<p>No titles to continue watching yet.</p>";
      }

      // (Optional) toast
      showPopup(`<b>${title}</b><br><span style="color:limegreen;">Removed from Continue Watching.</span>`);
    })
    .withFailureHandler(err => {
      // Roll back UI on error
      if (btn) btn.disabled = false;
      cardEl.style.opacity = '1';
      showPopup(`❌ Couldn't remove <b>${title}</b>.<br>${err?.message || 'Please try again.'}`);
    })
    .clearProfileProgress(profile, title);
}

function waitForImagesToLoad(container, { timeoutMs = 2500 } = {}) {
  // Fast‑path: if container missing, resolve immediately
  if (!container) return Promise.resolve();

  const images = Array.from(container.querySelectorAll("img"));

  // Fast‑path: nothing to wait on
  if (images.length === 0) return Promise.resolve();

  const inViewport = el => {
    const r = el.getBoundingClientRect();
    return r.top < window.innerHeight && r.bottom > 0 && r.left < window.innerWidth && r.right > 0;
  };

  const promises = images.map(img => {
    // Already loaded (covers cached images and ones with naturalWidth > 0)
    if (img.complete || img.naturalWidth > 0) return Promise.resolve();

    // If it's lazy and off‑screen, don't block the loader on it
    const isLazy = img.loading === 'lazy' || img.getAttribute('loading') === 'lazy';
    if (isLazy && !inViewport(img)) return Promise.resolve();

    // Otherwise, wait for load/error
    return new Promise(resolve => {
      const done = () => { img.onload = img.onerror = null; resolve(); };
      img.onload = done;
      img.onerror = done;
    });
  });

  const timeout = new Promise(res => setTimeout(res, timeoutMs));
  return Promise.race([Promise.all(promises), timeout]);
}

// Create card
function createCard(item, isTMDb = false, wishlistTitles = []) {
  const displayTitle = item.title || item.name || "No Title";
  const card = document.createElement("div");
  card.classList.add("movie-card");
  card.innerHTML = "";

  // Poster
  const img = document.createElement("img");
  img.src = item.poster;
  img.alt = displayTitle;
  img.loading = "lazy";
  card.appendChild(img);

  // Title
  const titleDiv = document.createElement("div");
  titleDiv.classList.add("movie-title");
  titleDiv.textContent = displayTitle;
  card.appendChild(titleDiv);

  // Wishlist button for TMDb items
  if (isTMDb) {
    // Store TMDb genre IDs for filtering
    const gids = Array.isArray(item.genre_ids) ? item.genre_ids : [];
    const btn = document.createElement("button");
    btn.classList.add("add-btn");

    const alreadyRequested = (wishlistTitles || []).some(w =>
      String(w.title || "").toLowerCase().trim() === displayTitle.toLowerCase().trim() &&
      w.status === "Wishlist"
    );

    if (alreadyRequested) {
      btn.textContent = "✔";
      btn.title = "Requested";
      btn.disabled = true;
      btn.style.backgroundColor = "green";
    } else {
      btn.textContent = "+";
      btn.title = "Add to Wishlist";
      btn.style.backgroundColor = "#e50914";
      btn.addEventListener("click", e => {
        e.stopPropagation();
        addToWishlist(displayTitle, item.poster, btn);
      });
    }
    card.appendChild(btn);
  }

  card.addEventListener("click", async () => {
    if (isTMDb) {
      // TMDb items: populate the TMDb Details Preview
      const preview = document.getElementById("tmdbDetailsPreview");
      const trailerContainer = document.getElementById("tmdbTrailerContainer");
      const titleEl = document.getElementById("tmdbDetailsTitle");
      const dateEl = document.getElementById("tmdbDetailsReleaseDate");
      const ovEl = document.getElementById("tmdbDetailsOverview");

      const data = await fetchTMDbDetails(item, item.media_type === "tv");
      if (!data) return;

      const trailer = data.videos?.results.find(v => v.type === "Trailer" && v.site === "YouTube");
      if (trailerContainer) {
        trailerContainer.innerHTML = trailer
          ? `<iframe id="tmdbTrailerFrame" src="https://www.youtube.com/embed/${trailer.key}"
               sandbox="allow-same-origin allow-scripts allow-presentation allow-popups allow-forms"
               allowfullscreen style="width:100%;height:100%;border:none;border-radius:12px;"></iframe>`
          : `<p><em>No trailer available.</em></p>`;
      }

      const titleText = data.name || data.title || displayTitle;
      if (titleEl) titleEl.textContent = titleText;
      if (dateEl) dateEl.innerHTML = `<strong>Release Date:</strong> ${data.first_air_date || data.release_date || "N/A"}`;
      if (ovEl) ovEl.textContent = data.overview || "No overview available.";

      if (preview) {
        preview.style.display = "block";
        setTimeout(() => preview.scrollIntoView({ behavior: "smooth", block: "start" }), 50);
      }

      // If there’s a matching local item with episodes, also show the episodes list beneath sections
      const local = findLocalByTitle(titleText);
      if (local?.episodes?.length) {
        showEpisodesList(local);
      } else {
        const epSec = document.getElementById("episodesSection");
        const epGrid = document.getElementById("episodesGrid");
        if (epSec) epSec.style.display = "none";
        if (epGrid) epGrid.innerHTML = "";
      }

    } else {
      // Local items: do NOT touch the TMDb Details Preview at all
      // Just open the episodes list
      showEpisodesList(item);
    }
  });

  return card;
}

function openEpisodeInNewTab(url, showTitle, episodeTitle = "") {

  // save progress
  if (currentProfile && showTitle) {
    google.script.run
      .withFailureHandler(err => console.warn("saveProfileProgress failed:", err))
      .saveProfileProgress(currentProfile, showTitle, episodeTitle);
  }

  // open in a new tab (popup‑blocker safe since it's in a click handler)
  try {
    window.open(url, "_blank", "noopener");
  } catch (e) {
    // fallback
    location.href = url;
  }
}

function showEpisodesList(showLike) {
  // Ensure episodesSection exists
  let section = document.getElementById("episodesSection");
  if (!section) {
    section = document.createElement("div");
    section.id = "episodesSection";
    section.style.display = "none";
    section.innerHTML = `
      <h2 class="subsection-title" id="episodesTitle"></h2>
      <div class="scroll-container" id="episodesGrid"></div>
    `;
    const cwSection = document.getElementById("continueWatchingSection");
    if (cwSection) cwSection.insertAdjacentElement("beforebegin", section);
    else document.body.appendChild(section);
  }

  const titleEl = document.getElementById("episodesTitle");
  const grid = document.getElementById("episodesGrid");
  if (!grid) return;

  // Hide TMDb preview for local items
  const preview = document.getElementById("tmdbDetailsPreview");
  if (preview) preview.style.display = "none";

  // Clear + show section
  grid.innerHTML = "";
  section.style.display = "block";

  const displayTitle = showLike.title || showLike.name || "Episodes";
  let eps = Array.isArray(showLike.episodes) ? [...showLike.episodes] : [];

  // If no episodes on the object, fetch them from the server by title.
  if (!eps.length && (showLike.title || showLike.name)) {
    const wantTitle = showLike.title || showLike.name;

    // Temporarily show a loading state in the grid
    const gridEl = document.getElementById("episodesGrid");
    if (gridEl) gridEl.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">Loading episodes…</p>';

    google.script.run
      .withSuccessHandler(payload => {
        const fromServer = Array.isArray(payload?.episodes) ? payload.episodes : [];
        if (!fromServer.length && payload?.url) {
          fromServer.push({ title: "Play", url: payload.url, poster: payload.poster || showLike.poster });
        }
        showEpisodesList({
          title: payload.title || wantTitle,
          poster: payload.poster || showLike.poster,
          episodes: fromServer
        });
      })
      .withFailureHandler(() => {
        if (gridEl) gridEl.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">No episodes found.</p>';
      })
      .getEpisodesByTitle(wantTitle);
    return; // stop here; the success handler will re-render
  }

  // If no episodes but we have a direct URL, create a single "Play" card
  if ((!eps || eps.length === 0) && showLike.url) {
    eps = [{ title: "Play", url: showLike.url }];
  }

  // ✅ Sort episodes alphabetically by title (case-insensitive)
  eps.sort((a, b) => {
    return (a.title || "").toLowerCase().localeCompare((b.title || "").toLowerCase());
  });

  const label = (eps.length > 1) ? "Episodes" : "Collection";
  titleEl.innerHTML = `${displayTitle} — <span style="opacity:.8">${label}</span>`;

  // Close button
  let closeBtn = titleEl.querySelector("button.episodes-close");
  if (!closeBtn) {
    closeBtn = document.createElement("button");
    closeBtn.className = "episodes-close";
    closeBtn.type = "button";
    closeBtn.textContent = "Close";
    closeBtn.addEventListener("click", () => {
      section.style.display = "none";
      grid.innerHTML = "";
    });
    titleEl.appendChild(closeBtn);
  }

  // Build cards
  if (!eps || eps.length === 0) {
    grid.innerHTML = '<p style="color:#aaa;font-size:24px;text-align:center;">No episodes found.</p>';
  } else {
    const last = getLastWatchedEpisodeFor(displayTitle);
    eps.forEach(ep => {
      const card = document.createElement("div");
      card.className = "movie-card";
      if (_norm(ep.title) === _norm(last)) card.classList.add("last-watched");
      card.innerHTML = `
        <img src="${ep.poster || showLike.poster}" alt="${ep.title}" loading="lazy">
        <div class="movie-title">${ep.title}</div>
      `;
      card.addEventListener("click", () => {
        // Visually select in the list
        grid.querySelectorAll(".movie-card").forEach(c => c.classList.remove("active-episode"));
        card.classList.add("active-episode");

        // Open in new tab + save progress
        openEpisodeInNewTab(ep.url, displayTitle, ep.title);
      });
      grid.appendChild(card);
    });
  }

  // Smooth scroll with header offset
  setTimeout(() => {
    const yOffset = -80; // adjust for sticky header height
    const y = section.getBoundingClientRect().top + window.scrollY + yOffset;
    window.scrollTo({ top: y, behavior: 'smooth' });
  }, 50);
}

// (Optional but harmless): ensure global
window.showEpisodesList = showEpisodesList;

// --- Available-to-Watch (batched) ---
const availableState = {
  initialized: false,
  loading: false,
  loaded: 0,
  items: [],
};

function buildAvailableList() {
  if (!window.library) return [];
  const { movies = [], tv = [] } = window.library;
  // Shuffle a fresh combined list
  return shuffleArray([...movies, ...tv]);
}

function appendAvailableItems(limit = 5) {
  const grid = document.getElementById("availableToWatchGrid");
  if (!grid || !availableState.items.length) return;

  const start = availableState.loaded;
  const end = Math.min(start + limit, availableState.items.length);
  for (let i = start; i < end; i++) {
    grid.appendChild(createCard(availableState.items[i]));
  }
  availableState.loaded = end;
}

function initAvailableToWatch() {
  const grid = document.getElementById("availableToWatchGrid");
  if (!grid) return;

  // reset state
  availableState.initialized = false;
  availableState.loading = false;
  availableState.loaded = 0;
  availableState.items = buildAvailableList();

  // skeletons then first batch
  grid.innerHTML = `
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
  `;

  requestAnimationFrame(() => {
    grid.innerHTML = "";            // clear skeletons
    appendAvailableItems(10);       // FIRST LOAD = 10
    availableState.initialized = true;

    // attach infinite scroll (only once per init)
    attachAvailableInfiniteScroll();
  });
}

function attachAvailableInfiniteScroll() {
  const el = document.getElementById("availableToWatchGrid");
  if (!el) return;

  // Remove any previous listener by cloning (keeps styles/children)
  const clone = el.cloneNode(true);
  el.parentNode.replaceChild(clone, el);

  clone.addEventListener("scroll", async () => {
    if (availableState.loading || !availableState.initialized) return;
    // near the right edge?
    if (clone.scrollLeft + clone.clientWidth >= clone.scrollWidth - 50) {
      availableState.loading = true;
      appendAvailableItems(5);      // SUBSEQUENT LOADS = 5
      availableState.loading = false;
    }
  });
}

// Load Library via google.script.run and sync wishlist statuses automatically
function loadLibrary(force = false) {
  // only skip if we've already loaded AND not forcing
  if (libraryLoaded && !force) return Promise.resolve();

  if (!libraryLoaded || force) {
    const container = document.getElementById("availableToWatchGrid");
    container.innerHTML = `
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
      <div class="skeleton-card"></div>
    `;
  }

  return new Promise(resolve => {
    google.script.run.withSuccessHandler(data => {
    fullLibrary = (data.movies || []).concat(data.tv || []);
    window.library = data;
    libraryLoaded = true;

    try {
      initAvailableToWatch(); // <-- batched initializer
    } catch (err) {
      console.error("❌ Error in initAvailableToWatch:", err);
      showPopup("Error rendering Available to Watch.");
    }
    resolve();
  }).withFailureHandler(err => {
      console.error("❌ Failed to load library:", err);
      showPopup("Error loading library.");
      resolve();
    }).getLibraryAndSyncWishlist();
  });
}

function refreshAvailableToWatch({ force = false } = {}) {
  if (force) return loadLibrary(true).then(() => initAvailableToWatch());

  if (window.library) {
    // Quick reshuffle without Drive call
    initAvailableToWatch(); // rebuilds list, loads 10, then scroll adds 5 at a time
    return Promise.resolve();
  }
  return loadLibrary().then(() => initAvailableToWatch());
}

let currentProfile = null;

const loadingScreen = document.getElementById("loadingScreen");
let _hideLoaderTimer = null;
function hideLoadingScreen(delay = 300) {
  if (_hideLoaderTimer) {
    clearTimeout(_hideLoaderTimer);
    _hideLoaderTimer = null;
  }
  _hideLoaderTimer = setTimeout(() => {
    loadingScreen.style.display = "none";
    _hideLoaderTimer = null;
  }, delay);
}

window.addEventListener("load", () => {
  const app = document.getElementById("appContent");
  const profileModal = document.getElementById("profileModal");

  app.style.display = "block";
  loadingScreen.style.display = "flex";

  let savedName = null, savedIcon = null;
  try {
    savedName = localStorage.getItem("lastProfileName");
    savedIcon = localStorage.getItem("lastProfileIcon") || "https://via.placeholder.com/50";
  } catch (e) {
    console.warn("localStorage unavailable:", e);
  }

  if (savedName) {
    // Start profile flow immediately (CW can start sooner)
    profileModal.classList.remove("active");
    selectProfile(savedName, savedIcon);
    // Warm above-the-fold rows in parallel
    Promise.all([ loadLibrary(), loadRecentlyAdded() ])
      .then(() => waitForImagesToLoad(app, { timeoutMs: 2500 }))
      .then(() => hideLoadingScreen())
      .catch(err => {
        console.error("❌ Error during preload:", err);
        showPopup("Something went wrong while preloading content.");
        hideLoadingScreen();
      });
  } else {
    // No saved profile → preload visible rows before pick
    Promise.all([ loadLibrary(), loadRecentlyAdded() ])
      .then(() => waitForImagesToLoad(app, { timeoutMs: 2500 }))
      .then(() => hideLoadingScreen())
      .catch(err => {
        console.error("❌ Error during preload:", err);
        showPopup("Something went wrong while preloading content.");
        hideLoadingScreen();
      });
    profileModal.classList.add("active");
  }

  // Manual profile selection
  document.querySelectorAll(".profile-btn").forEach(btn => {
    btn.addEventListener("click", () => {
      const chosenName = btn.dataset.profile;
      const imgEl = btn.querySelector("img");
      const chosenIcon = imgEl ? imgEl.src : "https://via.placeholder.com/50";
      selectProfile(chosenName, chosenIcon);
    });
  });

  // Switch profile from bottom bar
  const switchBtn = document.getElementById("switchProfileBtn");
  if (switchBtn) {
    switchBtn.addEventListener("click", () => {
      profileModal.classList.add("active");
    });
  }
});

document.getElementById("searchInput").addEventListener("input", function (e) {
  const query = (e.target.value || "").toLowerCase().trim();
  const searchResults = document.getElementById("searchResultsSection");
  const searchGrid = document.getElementById("searchResultsGrid");

  // Everything we hide/show during search
  const sectionsToToggle = [
    "continueWatchingSection",
    "recentlyAddedSection",
    "availableToWatchSection",
    "wishlistSection",
    "tmdbDetailsPreview",
    "episodesSection",
    "tmdbExploreAllSection",
    "tmdbExploreComedySection",
    "tmdbExploreWesternSection",
    "tmdbExploreActionSection",
    "tmdbExploreDramaSection",
    "tmdbExploreAnimationSection",
    "tmdbExploreHistorySection",
    "tmdbExploreRomanceSection",
    "tmdbExploreScifiSection"
  ];

  // If the library isn't ready, bail
  if (!Array.isArray(fullLibrary) || fullLibrary.length === 0) return;

  if (query === "") {
    // Show everything again
    sectionsToToggle.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = "block";
    });
    // Show the Explore header (h2.tmdb-title)
    const tmdbHeader = document.querySelector(".tmdb-title");
    if (tmdbHeader) tmdbHeader.style.display = "block";

    // Hide search results
    if (searchResults) searchResults.style.display = "none";
    if (searchGrid) searchGrid.innerHTML = "";
    return;
  }

  // Hide all non-search sections
  sectionsToToggle.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
  // Hide the Explore header (h2.tmdb-title)
  const tmdbHeader = document.querySelector(".tmdb-title");
  if (tmdbHeader) tmdbHeader.style.display = "none";

  // Show and populate search results
  if (searchResults) searchResults.style.display = "block";
  if (searchGrid) {
    searchGrid.innerHTML = "";
    const filtered = fullLibrary.filter(item =>
      (item.title || "").toLowerCase().includes(query)
    );
    if (filtered.length) {
      filtered.forEach(item => searchGrid.appendChild(createCard(item)));
    } else {
      searchGrid.innerHTML = '<p style="text-align:center;color:#aaa;font-size:24px;">No results found.</p>';
    }
  }
});

function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

const _norm = s => String(s || "").replace(/\u00A0/g, " ").trim().toLowerCase();
function findLocalByTitle(title) {
  if (!title || !window.library) return null;
  const { movies = [], tv = [] } = window.library;
  return [...movies, ...tv].find(x => _norm(x.title) === _norm(title)) || null;
}

// Cache of "last watched" by normalized title for current profile
let cwProgressByTitle = new Map();

function setCWCache(items = []) {
  cwProgressByTitle.clear();
  items.forEach(it => {
    if (it && it.title) {
      cwProgressByTitle.set(_norm(it.title), String(it.episode || ""));
    }
  });
}

function getLastWatchedEpisodeFor(title) {
  return cwProgressByTitle.get(_norm(title)) || "";
}

// WISHLIST
function addToWishlist(title, poster, btn) {
  // Immediately update UI
  if (btn) {
    btn.textContent = "✔";
    btn.style.backgroundColor = "green";
    btn.disabled = true;
  }

  google.script.run.withSuccessHandler(response => {
    if (!response) return;
    showPopup(`<b>${response.title}</b><br><span style="color:green;">Added to your wishlist!</span>`);
  }).withFailureHandler(err => {
    showPopup(`❌ Failed to add <b>${title}</b>. Error: ${err.message}`);
    // On failure, revert button UI back
    if (btn) {
      btn.textContent = "+";
      btn.style.backgroundColor = "#e50914";
      btn.disabled = false;
    }
  }).addToWishlistSheet(title, poster);
}
function renderWishlist(items) {
  const grid = document.getElementById('wishlistGrid');
  grid.innerHTML = '';

  // Normalize shapes/keys coming from server: {title, poster} OR {Title, Poster} etc.
  const normalized = (Array.isArray(items) ? items : []).map(it => {
    const title = (it && (it.title || it.Title || it.name || it.Name)) || 'Untitled';
    const poster = (it && (it.poster || it.Poster || it.image || it.Image)) || '';
    return { title: String(title).trim(), poster: String(poster).trim() };
  }).filter(it => it.title); // keep only valid titles

  if (normalized.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No requested items found.</p>';
    return;
  }

  shuffleArray(normalized).forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" onerror="this.style.display='none'">
      <div class="movie-title">${item.title}</div>
    `;
    grid.appendChild(card);
  });

  // Make sure the section is visible (harmless if already visible)
  const section = document.getElementById('wishlistSection');
  if (section) section.style.display = 'block';
}
function loadWishlist() {
  return new Promise(resolve => {
    // Ping (optional but useful to confirm we’re on the right deployment)
    google.script.run
      .withSuccessHandler(v => console.log('PING (server version):', v))
      .withFailureHandler(err => console.warn('PING failed:', err))
      .pingWishlistVersion();

    // Fetch wishlist from the server
    google.script.run
      .withSuccessHandler(items => {
        renderWishlist(items || []);
        resolve();
      })
      .withFailureHandler(err => {
        console.error('getRequestedWishlist failed:', err);
        renderWishlist([]);
        resolve();
      })
      .getRequestedWishlist();
  });
}

// RECENTLY ADDED
function renderRecentlyAdded(items) {
  const grid = document.getElementById('recentlyAddedGrid');
  grid.innerHTML = '';
  if (!items || items.length === 0) {
    grid.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No recent videos found.</p>';
    return;
  }

  // Items are already sorted newest → oldest by the server
  items.forEach(item => {
    const card = document.createElement('div');
    card.classList.add('movie-card');
    card.innerHTML = `
      <img src="${item.poster}" alt="${item.title}" loading="lazy" decoding="async">
      <div class="movie-title">${item.title}</div>
    `;
    card.addEventListener('click', () => {
      showEpisodesList(item);
    });
    grid.appendChild(card);
  });
}
function loadRecentlyAdded() {
  const grid = document.getElementById('recentlyAddedGrid');
  grid.innerHTML = `
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
    <div class="skeleton-card"></div>
  `;

  return new Promise(resolve => {
    google.script.run.withSuccessHandler(items => {
      renderRecentlyAdded(items);
      resolve();
    }).withFailureHandler(err => {
      console.error("❌ Failed to load recently added:", err);
      showPopup("Error loading recently added.");
      resolve();
    }).getRecentVideos(14);
  });
}

// CONTINUE WATCHING
function loadContinueWatching() {
  if (!currentProfile) {
    console.log("⚠️ No currentProfile, skipping continue watching");
    return Promise.resolve();
  }

  const ensureLibrary = window.library ? Promise.resolve() : loadLibrary();

  return ensureLibrary.then(() =>
    new Promise(resolve => {
      google.script.run
        .withSuccessHandler(data => {
          renderContinueWatching(data || []);
          resolve();
        })
        .withFailureHandler(err => {
          console.error("❌ getContinueWatching failed:", err);
          resolve();
        })
        .getContinueWatching(currentProfile);
    })
  );
}
function renderContinueWatching(items) {
  // newest → oldest by updatedAt; if missing, they fall to the bottom
  items = (items || []).slice().sort((a, b) => {
    const ta = Date.parse(a.updatedAt || '') || 0;
    const tb = Date.parse(b.updatedAt || '') || 0;
    return tb - ta;
  });

  setCWCache(items || []);
  const container = document.getElementById("continueWatchingGrid");
  if (!container) return;
  container.innerHTML = "";

  if (!items || !Array.isArray(items) || items.length === 0) {
    container.innerHTML = "<p>No titles to continue watching yet.</p>";
    return;
  }

  const library = window.library;
  if (!library) return;

  const normalize = (str) => (str || "").replace(/\u00A0/g, " ").trim().toLowerCase();

  items.forEach((item) => {
    const driveItem = [...library.movies, ...library.tv].find(
      (lib) => normalize(lib.title) === normalize(item.title)
    );
    if (!driveItem) return;

    const card = document.createElement("div");
    card.className = "movie-card";
    card.style.position = "relative";

    card.innerHTML = `
      <img src="${driveItem.poster}" alt="${driveItem.title}" loading="lazy" decoding="async">
      <div class="movie-title">${driveItem.title}</div>
      <button class="cw-complete-btn" title="Remove from Continue Watching" aria-label="Remove ${driveItem.title} from Continue Watching">−</button>
    `;

    card.addEventListener("click", (e) => {
      const el = e.target;
      if (el && typeof el.closest === "function" && el.closest(".cw-complete-btn")) return;
      showEpisodesList(driveItem);
    });

    const completeBtn = card.querySelector(".cw-complete-btn");
    if (completeBtn) {
      completeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        const confirmMsg = item.episode
          ? `Mark "${driveItem.title}" — "${item.episode}" as complete?`
          : `Mark "${driveItem.title}" as complete?`;
        if (!window.confirm(confirmMsg)) return;
        markComplete(currentProfile, driveItem.title, card, item.episode || "");
      });
    }

    container.appendChild(card);
  });

  document.getElementById("continueWatchingSection").style.display = "block";
}

// DETAILS & TRAILERS
async function fetchTMDbDetails(item, isTV = false) {
  return new Promise(resolve => {
    google.script.run
      .withSuccessHandler(data => {
        if (!data || data.error) {
          const trailerContainer = document.getElementById('tmdbTrailerContainer');
          const titleElem = document.getElementById('tmdbDetailsTitle');
          const dateElem = document.getElementById('tmdbDetailsReleaseDate');
          const overviewElem = document.getElementById('tmdbDetailsOverview');
          const preview = document.getElementById('tmdbDetailsPreview');

          if (trailerContainer) trailerContainer.innerHTML = '<p><em>Details not available for this title.</em></p>';
          if (titleElem) titleElem.textContent = item.title || item.name || 'Unknown';
          if (dateElem) dateElem.innerHTML = '';
          if (overviewElem) overviewElem.textContent = 'We could not load details from TMDb.';
          if (preview) preview.style.display = 'block';
          resolve(null);
          return;
        }
        resolve(data);
      })
      .withFailureHandler(() => {
        resolve(null);
      })
      .getTMDbDetails(item.id, isTV);
  });
}

const GENRES = { 
  comedy:'35', western:'37', action:'28', drama:'18', animation:'16', history:'36', scifi:'878' 
};

function _dedupe(items) {
  const seen = new Set();
  return (items || []).filter(it => {
    const key = `${it.id}|${it.media_type || (it.first_air_date ? 'tv' : 'movie')}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function _append(row, items) {
  if (!row) return;
  row.innerHTML = '';
  if (!items || !items.length) {
    row.innerHTML = '<p style="color:#aaa; font-size:24px; text-align:center;">No items found.</p>';
    return;
  }
  const frag = document.createDocumentFragment();
  items.forEach(it => frag.appendChild(createCard(it, true, wishlistRequestedTitles)));
  row.appendChild(frag);
}

// Helper to call Apps Script; returns [] on failure
function callScript(fn, ...args) {
  return new Promise(resolve => {
    try {
      google.script.run
        .withSuccessHandler(res => resolve(Array.isArray(res) ? res : []))
        .withFailureHandler(() => resolve([]))[fn](...args);
    } catch (_) {
      resolve([]);
    }
  });
}

// Top-rated discover with automatic fallback to trending
async function fetchMixedTopRated(genreId, count = 12) {
  // First attempt: top-rated discover
  const [m1, t1] = await Promise.all([
    callScript('getDiscoverByGenreType', 'movie', 1, 'US', genreId || ''),
    callScript('getDiscoverByGenreType', 'tv',    1, 'US', genreId || '')
  ]);
  let merged = _dedupe([...(m1 || []), ...(t1 || [])]);

  // Fallback: trending if discover came back too thin
  if (!merged.length) {
    const [m2, t2] = await Promise.all([
      callScript('getTrendingByType', 'movie', 1),
      callScript('getTrendingByType', 'tv',    1)
    ]);
    merged = _dedupe([...(m2 || []), ...(t2 || [])]);
  }
  return merged.slice(0, count);
}

async function loadExploreRows() {
  await ensureWishlistAll();

  const rows = [
    ['',                'tmdbExploreAllRow'],
    [GENRES.comedy,     'tmdbExploreComedyRow'],
    [GENRES.western,    'tmdbExploreWesternRow'],
    [GENRES.action,     'tmdbExploreActionRow'],
    [GENRES.drama,      'tmdbExploreDramaRow'],
    [GENRES.animation,  'tmdbExploreAnimationRow'],
    [GENRES.history,    'tmdbExploreHistoryRow'],
    [GENRES.scifi,      'tmdbExploreScifiRow']
  ];

  for (const [genre, rowId] of rows) {
    const items = await fetchMixedTopRated(genre);
    _append(document.getElementById(rowId), items);
  }
}

function loadWishlistRequested() {
  // Backward-compatible shim; use ensureWishlistAll internally
  return ensureWishlistAll().then(() => {});
}

function checkStickyShadow() {
  const stickyOffset = 100;  // or your preferred threshold
  const titles = document.querySelectorAll('.section-title, .tmdb-title');
  titles.forEach(el => {
    const rect = el.getBoundingClientRect();
    if (rect.top <= stickyOffset) {
      el.classList.add('sticky-shadow');
    } else {
      el.classList.remove('sticky-shadow');
    }
  });
}

window.addEventListener('scroll', checkStickyShadow);
window.addEventListener('load', checkStickyShadow);

waitForImagesToLoad(document.getElementById('appContent')).then(() => {
});

document.getElementById("mobileExploreRefresh").addEventListener("click", async () => {
  await loadExploreRows();  // reload all Explore lists
  console.log("Explore lists refreshed");
});

// --- Refresh: Available to Watch (tap = reshuffle, long-press = force reload) ---
let _availRefreshPressTimer = null;
let _availDidLongPress = false;
const availBtn = document.getElementById("mobileAvailableRefresh");

function _scheduleAvailLongPress() {
  _availDidLongPress = false;
  _availRefreshPressTimer = setTimeout(() => {
    _availDidLongPress = true; // so the subsequent 'click' is ignored
    refreshAvailableToWatch({ force: true })
      .then(() => showPopup("Available to Watch reloaded"));
  }, 600); // long-press threshold
}
function _cancelAvailLongPress() {
  if (_availRefreshPressTimer) {
    clearTimeout(_availRefreshPressTimer);
    _availRefreshPressTimer = null;
  }
}

// Quick tap = reshuffle (no Drive call)
availBtn.addEventListener("click", () => {
  if (_availDidLongPress) { _availDidLongPress = false; return; } // suppress extra reshuffle after long-press
  refreshAvailableToWatch().then(() => console.log("Available to Watch reshuffled"));
});

// Long-press support for mouse & touch
availBtn.addEventListener("mousedown", _scheduleAvailLongPress);
availBtn.addEventListener("touchstart", _scheduleAvailLongPress, { passive: true });

["mouseup", "mouseleave", "touchend", "touchcancel"].forEach(evt => {
  availBtn.addEventListener(evt, _cancelAvailLongPress);
});

let libraryLoaded = false;
</script>
</body>
</html>
